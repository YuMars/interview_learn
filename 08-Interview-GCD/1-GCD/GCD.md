1. GCD 简介
2. GCD 任务和队列
3. GCD 的使用步骤
4. GCD 的基本使用（六种组合不同区别，队列嵌套情况区别，相互关系形象理解）
5. GCD 线程间的通信
6. GCD 的其他方法（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore）


1.GCD = Grand Central Dispatch 
    一个在线程池模式的基础上执行的并发任务。
	
	好处：
		GCD用于多核的并行运算；
		GCD会自动利用更多的CPU内核；（双核、四核）
		GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）
		只需要告诉GCD想要执行什么，不需要变成任何线程管理代码。


2.GCD 任务和队列

任务：执行操作的意思，即执行的代码。在GCD中放在Block里。执行的方式有两种：『同步执行』和『异步执行』。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启线程的能力。

同步执行：
	1.同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。
	2.只能在当前线程中执行任务，不具备开启新线程的能力。

异步执行：
	1.异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。
	2.可以在新的线程中执行任务，具备开启新线程的能力。

eg:
	同步执行：执行任务A的时候不能执行任务B，等任务A执行完才能继续执行任务B
	异步执行：执行任务A的时候同时执行任务B，甚至任务C。

队列：指执行任务的等待队列，即用来存放任务的队列。队列是线性表，采用FIFO（先进先出）原则，新任务总是被插入到队列的末尾，读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。
	GCD中有两种队列：『串行队列』和『并发队列』，符合FIFO（先进先出）的原则，主要区别：执行顺序不同，已经开启的线程数不同。

串行队列：每次只有一个任务被执行。让任务一个接着一个执行。（只开启一个线程，一个任务执行完毕后再执行下一个任务）

并发队列：可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）


3.GCD的使用步骤
	1.创建一个队列（串行队列或者并发队列）；
	2.将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步或异步执行）。

3.1 队列的创建、获取
// 串行队列
dispatch_queue_t serialQueue = dispatch_queue_create("net.gcdtest.testqueue", DISPATCH_QUEUE_SERIAL);
        
// 并发队列
dispatch_queue_t concurrentQueue = dispatch_queue_create("com.gcdtest.testqueue", DISPATCH_QUEUE_CONCURRENT);
        
// 主队列
dispatch_queue_t quueue = dispatch_get_main_queue();

// 全局并发队列
dispatch_queue_t queueGloable = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

3.2 任务的创建


// 同步执行任务创建
dispatch_sync(quueue, ^{

});
        
// 异步执行任务创建
dispatch_async(quueue, ^{

});

1.同步执行+串行队列
2.同步执行+并发队列
3.异步执行+串行队列
4.异步执行+并发队列
5.同步执行+主队列
6.异步执行+主队列

3.3 任务和队列不同组合方式的区别
	主线程：
  				并发队列 				 		串行队列 						主队列
	同步   没有开启新线程，串行执行任务   没有开启新线程，串行执行任务       死锁卡住不执行（主线程追加同步任务，和主线程的任务互相等待）
	异步   有开启新线程，并发执行队列     有开启新线程，串行执行队列	没有开启新线程，串行执行任务


3.4 队列嵌套，不同组合方式区别
	『异步执行』+『串行队列』，嵌套『当前的串行队列』，『同步执行』。会死锁
	dispatch_queue_t queue = dispatch_queue_create("com.test.queue", DISPATCH_QUEUE_SERIAL);
	dispatch_asnyc(queue, ^{ // 异步执行 + 串行队列
		dispatch_sync(queue, ^{ // 同步执行 + 当前队列
			[NSThread sleepForTimeInterval:2];
		});
	});

	『不同队列』 + 『不同任务』

				异步执行+并发队列  					同步执行+并发队列 				异步执行+串行队列 				同步执行+串行队列
				嵌套同一个并发队列						嵌套同一个并发队列				嵌套同一个串行队列 			嵌套一个串行队列
	同步       没有开启新的线程，串行执行任务        没有开启新线程，串行执行任务       	  死锁卡住不执行 		    	死锁卡住不执行
	异步      有开启新的线程，并发执行任务           有开启新线程，并发执行任务		有开启新线程，串行执行任务        有开启新线程，串行执行任务


4.GCD的基本使用
	4.1同步执行+并发队列：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。
		1.所有任务都在当前线程执行，没有开启新的线程
		2.所有任务都按顺序依次执行
		3.虽然并发队列开启多个线程，并且同时执行多个任务，但是本身不能创建新线程。

	4.2异步执行+并发队列：可以开启多个线程，任务交替（同时）执行。
		1.除了当前线程，系统会开启其他线程，任务是交替或者同时执行的。
		2.当前线程没有等待，直接开启了新线程，在新线程中执行任务

	4.3同步执行+串行队列：不会开启新线程，在当前线程执行任务，任务是串行的，执行一个再执行下一个
		1.所有任务都在当前线程执行，没有开启新线程
		2.任务是按顺序依次执行

	4.4异步执行+串行队列：会开启新线程，但是任务是串行的，执行完一个任务在执行下一个任务
		1.开启了新线程，开了一个
		2.任务是按顺序执行

	4.5主队列
		4.5.1 主线程+同步执行+主队列：互相等待，导致死锁
		4.5.2 其他线程+同步执行+主队列：不会开启新线程，执行完一个任务，再执行下一个任务

	4.6异步执行+主队列：只在主线程中执行任务，执行完一个任务，在执行下一个任务
		1.所有任务都在主线程执行，没有开启新线程。
		2.打印完begin-end之后才执行
		3.按顺序执行任务

5.GCD线程间的通信
	一般在主线程里面刷新UI：点击，滚动，拖拽。把耗时操作放在其他线程，比如图片下载，文件上传等，等完成了耗时曹祖哦，返回到主线程，这时就需要用到线程通信。
	
6.GCD的其他方法
	6.1 GCD栅栏方法：dispatch_barrier_async
		1.需要异步执行两组操作，而且第一组操作执行完之后才能执行第二组操作。需要使用栅栏将两组异步执行的操作给分割起来（操作可以包含一个或多个任务）
		2.dispath_barrier_async 方法会等待前面追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列。然后在dispath_barrier_async方法追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。
		3.在执行完栅栏前面的操作之后，才执行栅栏操作，再执行栅栏之后的操作。

	6.2 GCD延迟执行方法: dispatch_after 指定时间后执行任务
		1.dispatch_after 并不在指定时间之后才开始执行，是指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但是想要大致延迟执行任务，是很有效的。
		
	6.3 GCD一次性代码（单例）: dispatch_once
		1.创建单利、或者有整个程序运行过程中只执行一次的代码时，就要用到dispatch_once方法。使用dispatch_once方法能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的情况下，dispatch_once也可以保证线程安全。

	6.4 GCD快速迭代方法：dispatch_apply
		1.通常会用for循环遍历，但是GCD提供了快速遍历的方法，dispatch_apply按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。
		2.如果是在串行队列中使用 dispatch_apply,那么就和for循环一样，按顺序同步执行。
		3.并发队列异步执行进行快速遍历
		4.无论串行队列还是并发队列，dispatch_apply都会等全部任务执行完毕
		5.并发队列中异步执行任务，哥哥任务的执行时间长短不定，最后结束循序也不定，但是dispatch_apply会等全部任务执行完毕。

	6.5 GCD队列组：dispatch_group 需要异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行任务，这个时候可以用到GCD
		1.调用队列组 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave组合来实现dispatch_group_async
		2.调用队列组 dispatch_group_notify 回到指定线程执行任务。或者使用dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）

		6.5.1 dispatch_group_notify 监听group中任务的完成状态，当所有的任务都执行完成后，追加任务到group中
			所有任务都执行完之后，才执行dispatch_group_notify 相关block中的任务
		6.5.2 dispatch_group_wait 暂停当前线程（阻塞当前线程），等待指定的group中任务执行完成后，才会往下继续执行。
			所有任务执行完成之后，才执行dispatch_group_wait之后的操作，会阻塞当前线程
		6.5.3 dispatch_group_enter、dispatch_group_leave
			1.dispatch_group_enter 标志着一个任务追加到group，执行一次，相当于group中未执行完毕任务数+1
			2.dispatch_grouo_leave 标志着一个任务离开了group，执行一次，相当于group中未执行完毕任务书-1
			3.当group中未执行完毕任务数为0的时候，才会使dispatch_group_wait解除阻塞，以及执行追加到diaptch_group_notify中的任务。
			4.当所有任务执行完成之后，才执行dispatch_group_notify中的任务。类似dispaatch_group_async

	6.6 GCD信号量：dispatch_semaphore 持有计数的信号，计数小于0时等待-不可通过，计数大于或等于0时，计数减1且不等等待，可通过。
		dispatch_semaphore_create:创建一个Semaphore并初始化信号的总量
		diapatch_semaphore_signal:发送一个信号，让信号总量加1
		dispatch_semaphore_wait:可以使总信号量减1，信号总量小于1时，就会一直等待（阻塞所在线程）否则就可以正常执行。
		dispatch_semaphore 在开发中主要用于：1.保持线程同步，讲异步执行任务转换为同步执行任务。2.保证线程安全，为线程加锁。

		6.6.1 dispatch_semaphore线程同步
			异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于将异步任务转换为同步任务。
				比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。
			1.semaphore 初始创建时计数为 0。
			2.异步执行 将 任务1 追加到队列之后，不做等待，接着执行 dispatch_semaphore_wait 方法，semaphore 减 1，此时 semaphore == -1，当前线程进入等待状态。
			3.然后，异步任务 1 开始执行。任务 1 执行到 dispatch_semaphore_signal 之后，总信号量加 1，此时 semaphore == 0，正在被阻塞的线程（主线程）恢复继续执行。
			4.最后打印 semaphore---end,number = 100。

		6.6.2 dispatch_semaphore 线程安全和线程同步（为线程加锁）
			线程安全：代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行结果是一样的，而且其他变量的值也和预期的是一样的，就是线程安全。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若多个线程同时执行写操作（更改变量），一般都是需要考虑线程同步，否则的话就可能影响线程安全。

			线程同步：可以理解为线程A和线程B一块配置，A执行到一定程度时要依靠线程B的某个结果，于是停下来，示意B运行；B执行，将结果给A，A在继续操作。

			6.6.2.1 非线程安全（不使用semaphore）
			6.6.2.2 线程安全（使用semaphore）















