网络

网络互连模型

OSI参考模型（7层）（Open System Interconnect Reference Model）
应用层
表示层
会话层
运输层
网络层
链路层
物理层

TCP/IP协议（4层）
应用层（应用层、表示层、会话层）
运输层
网际层（网络层）
网络接口层（数据链路层、物理层）

学习研究（5层）
应用层（应用层、表示层、会话层） （报文）       HTTP-1.1-GET       				 FTP、HTTP、SMTP、DNS、DHCP  
运输层 						 （段Segments） TCP头：包含端口号、序列号				 TCP、UDP
网际层（网络层）				 （包Packets）  IP头：包含IP地址-目标IP地址-源IP地址-协议（ICMP=1、TCP=6、UDP=17） IP、ARP、ICMP
数据链路层 					 （帧frames）   以太网头：包含Mac地址-以太网相关信息              CSMA/CD、PPP
物理层  						 （比特流bits）

分层的好处：
	1.各层独立:限制了依赖关系的范围，各层之间使用标准化的接口，各层不需要知道山西盖层是如何工作的，增加或者修改一个应用层协议不会影响传输层协议。
	2.灵活性更好：比如路由器不需要应用层和传输层，分层以后路由器就可以只需加载更少的几个协议层
	3.易于测试和维护：提高了可测试性，可以独立的测试特定层，某一层有了更好的实现可以整体替换掉
	4.能促进标准化：每一层职测清楚，方便进行标准化



# 物理层：定义了接口标准、线缆标准、传输速率、传输方式等
	模拟信号：
	1.连续的信号，适合长距离传输
	2.抗干扰能力差，收到干扰时波形变形很难纠正

	数字信号：
	1.离散的信号，不适合长距离传输
	2.抗干扰能力强，收到干扰时波形失真可修复

	数据通信模型
		局域网
		PC ----数字信号（网线）---- 交换机 -----数字信号（网线）------ PC

		广域网
		PC ----数字信号（网线）---- 调制解调器 ----- 模拟信号（电话线）----- 调制解调器 ----- 数字信号（网线）------ PC

	信道（Channel）
		信息传输的通道，一条传输介质上（比如网线）可以有多条信道
		单工通信：信号只能往一个放线传输，任何时候都不能改变信号的传输反向（无线电广播）
		半双工通信：信号可以双向传输，但是必须交通通行（对讲机）
		全双工通信：信号可以同时双向传输（手机）

# 数据链路层：
	链路：从一个节点到相邻节点的一段物理线路，中间没有其他交换节点
	数据链路：在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输。不同类型的数据链路，通信协议可能不同。
		广播信道：CSMA/CD协议（不如同轴电缆，集线器等组成的网络）
		点对点信道：PPP协议（比如路由器之间的信道）
	数据链路的3个基本问题：
		1.封装成帧
			帧的数据部分：网络层传递下来的数据包（IP数据包）
			最大传输单元：每一种数据链路协议都规定了所能够传输的帧的数据长度上限，以太网的最大传输单元1500字节
		2.透明传输
			数据部分一旦出现SOH、EOT需要进行转义（用ESC填充）
		3.差错检验
			FCS：根据数据部分+首部计算得出

	CSMA/CD协议
		1.载波侦听多路访问/冲突检测
		使用率CSMA/CS的网络可以成为以太网，它传输的是以太网帧
			以太网帧的格式有：Ethernet V2标准、IEEE的802.3标准
			使用最多的是：Ethernet V2标准
		为了能够检测正在发送的真是否产生冲突，以太网的帧至少要64字节

		用交换机组件的网络，已经支持全双工通信，不需要再使用CSMA/CD，但它传输的帧依然是以太网帧，所以交换机组件网络，依然可以叫做以太网

	Ethernet V2帧 
																								IP层
						6 		 6        2        					46-1500	         	4
					目标Mac地址-源Mac地址-类型（IPV6、IPV4）--------数据（IP数据包）-------FCS 		MAC层
				8字节|						以太网Mac帧	  					|       			物理层
前同步码7 ---帧开始定界符1----												没有帧结束符

	首部：源MAC地址+目标MAC地址+网络类型
	以太网帧：首部+收据+FCS
	数据的长度至少是：64-6-6-2-4=46

	当数据部分的长度小于46字节时：1.数据链路层会在数据的后面加入一些字节填充2.接收端会将添加的字节去掉
	长度总结：以太网帧的数据长度46-1500 以太网帧的长度：64-1518（源Mac地址+目标MAC地址+网络类型+数据+FCS）

	PPP协议（Point to Point Potocol）

			| 	      首部	   		  |
			F  ---- A ---- C ---- 协议 ---- 信息部分 ---- FCS ---- F
	字节数   1       1      1       2     不 超过1500字节  2       1
 

# 网络层
	网络层数据包（IP数据包，Packet）由首部、数据2部分组成
	数据：很多时候是有传输层传递下来的数据段

			|                  32位					|
	——————	版本 --- 首部长度 --- 区分服务 ---   总长度
	首部		标识 --- 标志 --- 片偏移
	20字节	生存时间 --- 协议 --- 首部检验和
			源IP地址
	——————	目标IP地址
			可选字段（长度可变） --- 填充
			数据部分（最大1460）
			|  			总长度65535位				|

	版本：占4位 IPV6、IPV4
	首部长度：占4位，二进制乘以4才是最终长度，20最小值，60最大值
	区分服务：(QOS)占8位，可以用于提高网络质量
	总长度：占16位 首部+数据的长度之和，最大值是65535。
		由于帧的数据不能超过1500字节，所以过大的IP数据包，需要分成片传输给数据链路层
		每一篇都有自己的网络层首部
	标识：占16位，数据包的ID，当数据包过大进行分片时，同一个数据包的所有片的标识都一样，有一个计数器专门管理数据包的ID，每发出一个数据包，ID就+1
	标志：占3位，第一位：（Reserved bit）保留。第二位：（Don't Fragment）1代表不允许分片，0代表允许。第三位：（More fragments）1代表不是最右一片，0代表是最后1片。··
	片偏移：占13位，片偏移乘以8=字节偏移，每一片段长度一定是8的整数倍 
	生存时间（TTL）：占8位，每个路由器在转发之前会将TTL减1，一旦发现TTL减为0，路由器会返回错误报告。观察使用ping命令后的TTL，能够推测出对方的操作系统，中间经历了多少个路由器
		Window： 128
		Linux：64（255）
		Mac OS：60
		Mac OS X：64 


# 传输层（TCP：Transmission Control Protocol）
	传输层有两个协议：1.TCP，传输控制协议
					2.UDP（User Datagram Protocol），用户数据报协议
								 		TCP 									UDP
		连接性						面向链接									无连接
		可靠性						可靠传输，不丢包							不可靠传输，尽最大努力交付，可能丢包
		首部占用空间					大 											小
		传输速率  					慢 											快
		资源消耗						大 											小
		应用场景						浏览器、文件传输、邮件发送 						音视频通话、直播
		应用层协议					HTTP、HTTPS、FTP、SMTP、DNS					DNS


	UDP
	UDP是无连接，减少了建立和释放链接的开销
	UDP尽最大能力交付，不保证可靠交付，隐藏不需要维护一些复杂的参数，首部只有8个字节（TCP首部至少20字节）
	UDP长度：占16位，首部的长度+数据的长度
													 ————————	
				16位源端口号 				16位目标端口号  |  
				16位UDP长度				16位UDP检验和  8字节
				数据 								 ————————
	检验和：计算内容=伪首部+首部+数据
			伪首部：源IP地址、目标IP地址、0（保留）、17（协议）、UDP长度 
			首部：源端口、目标端口、长度、检验和
	端口：占16位，可以推测出端口号的取值范围是0-65535，客户端的端口是临时开启的随机端口，防火墙可以设置开启、关闭某些端口提高安全性
		netstat -an:查看被占用的端口
		netstat -anb：查看被占用的端口、占用端口的应用程序
		telnet 主机 端口：查看市口可以访问主机的 某个端口


	TCP
	| 								16字节								|			16字节					|	
	----	源端口  																目标端口
			序列号
	20字节	确认号
			数据偏移	 	保留（flags） URG  ACK   PSH   RST   SYN   FIN   		窗口大小
	----	检验和    															紧急指针
			选项（长度可变） 														填充
 
 	序列号：占4字节。传输过程的每一个字节都会有一个编号，在建立连接后，序号代表：这一次传给对方的TCP数据部分的第一个字节的编码
 	确认号：占4字节。在建立连接后，确认号代表：期望对方下一次传过来的TCP数据部分的第一个字节的编号 
 	窗口：占2字节，这个字段有流量控制功能，能以告知对方下一次允许发送的数据大小（字节为单位）
	数据偏移：占4位，取值范围0x0101-0x1111，数据便宜乘以4=首部长度

			 UDP首部中占16位的长度字段是冗余的，纯粹是为了保证首部是32bit对齐
			 TCP/IP的数据长度，完全可以由IP数据包的首部推测出来
			 传输层的数据长度=网络层的总长度-网络层首部的长度-传输层首部的长度
	检验和： 伪首部+首部+数据
			伪首部：占用12字节，仅在计算检验和时起作用，并不会传递给网络层
	URG：（Urgent） 当URG = 1时，紧急指针字段才有效。表明当前报文段中有紧急数据，应优先尽快传递
	ACK：（Acknowledge） 当ACK = 1时，确认号字段才有效
	PSH：（Push）
	RST：（Reset） 当RST = 1时，表明连接中出现严重差错，必须释放连接，然后重新建立链接。
	SYN：（Synchroinzation） 当SYN = 1，ACK = 0时，表示这是一个建立链接的请求，若对方同意建立链接，则恢复SNY = 1，ACK = 1
	Fin：（Finish） 当Finsh = 1时，表明数据已经发送完毕，要求释放连接

	可靠传输：
		ARQ：Automatic Repeat-request，自动重传请求
		停止等待ARQ协议：等收到确认消息后再发送新的数据
		连续ARQ协议+滑动窗口协议： 如果接收窗口最多能接收4个包，但发送发只发了2个包，接受方等到一定时间后没收到第3个包，就回返回确认收到第2个包
		SACK（选择性确认）：
			1.在TCP通信过程中，如果发送序列中间某个数据包丢失（1、2、3、4、5丢了3），TCP会通过重传最后确认的分组后续的分组（最后确认2，所以重传3、4、5），这样原先已经正确传输的分组也可能重复发送，降低了TCP性能。为了改善上述情况，发展除了SACK（Selective Acknowledgment），告诉发送方哪些数据丢失，哪些数据已经收到。使用TCP只重新发送（3），不用发送的后续分组（4、5）。
			2.SACK信息会放在TCP首部的可选部分。Kind占一个字节 = 5，Length占一个字节，表明SACK一共占用多少字节。Left Edge：占4字节，左边界。Right Edge：占4字节，右边界。一堆边界信息需要占用8字节，由于TCP首部的选项部分最多40字节，所以SACK选项最多携带4组边界信息，SACK选项的最大占用字节数 = 4 * 8+2 = 34
		

	流量控制：
		如果接收方的缓存区满了，发送方还在发送数据，接收方只能把收到的数据包丢掉，大量的丢包会浪费网络资源，所以需要进行流量控制。
		什么是流量控制？让发送方的发送速率不要太快，让接收方来得及接收处理。
		原理：通过确认报文中窗口字段来控制发送方的发送速率，发送方的窗口大小不能超过接收方给出的窗口大小，当发送方收到的接收窗口大小为0时，发送方就回停止发送数据。

		特殊情况：开始接收方给发送方发送了0窗口的报文段，后面接收方有一些接收空间了，给发送方发送的非0窗口报文段丢失，发送方的发送窗口一直为0，双方陷入僵局
		解决方案：当发送方收到0窗口通知时，发送方停止发送报文，并且通知开启一个定时器，隔一段时间就发个测试报文去询问接收方最新的窗口大小，如果接收到窗口大小还是0，则发送方再次刷新启动定时器。


	拥塞控制：
		防止过多的数据注入到网络中，避免网络中的路由器或者链路过载。
		拥塞控制是一个全局性的过程，涉及到所有的主机、路由器以及与降低网络传输性能有关的所有因素，相比而已流量控制是点对点通信的控制。

		慢开始（slow start）：cwnd的初始值比较小，然后随着数据包被接收方确认，cwnd就成倍增长
		拥塞避免（congestion avoidance）：拥塞窗口缓慢增大，以防止网络过早出现拥塞，只要网络出现拥塞，把ssthresh减半，同时执行慢开始算法
		快速重传（fast retransmit）：接收方每收到一个失序的分组后就立即发出重复确认，使发送方及时知道有分组没有达到，而不要等待自己发送数据时才确认。发送方只要连续收到3个重复确认（总共4个相同的确认），就应该立即重传对方尚未收到的报文段，而不必继续等待重传计时器到后期再重传。
		快速恢复（fast recovery）：当发送方连续收到3个重复确认，就执行乘法减小算法，把ssthresh减半，与慢开始不同之处是现在不执行慢开始算法，即swnd现在不恢复到初始值二十吧cwnd设置为sshthresh减半后的值，然后开始执行拥塞避免算法，使拥塞窗口缓慢线性增大。
			MSS（Max Segment Size）：每个段最大的数据部分大小
			cwnd（congestion window）：拥塞窗口
			rwnd（receive window）：接收窗口
			swnd（send window）：发送窗口
			ssthresh（slow start threshold）：慢开始阈值，cwnd达到阈值后，以线性方式增加。





	连接管理： 
		确认号、序号
	 		---- SYN = 1 ACK = 0 seq = s1     ack = 0      --->
	 client	<--- SYN = 1 ACK = 1 seq = s2     ack = s1 + 1 ----	server
	 		---- SYN = 0 ACK = 0 seq = s1 + 1 ack = s2 +1  --->

	 	建立连接-3次握手
	 			客户端 																		服务端
	 			closed（关闭）  			> SYN = 1 ACK = 0 seq = s1     ack = 0 1 > 			listen(监听)
	 			syn-send（同步已发送）    < SYN = 1 ACK = 1 seq = s2     ack = s1 + 1 <		syn-rcvd（同步已接收）
				established（连接已经建立）> SYN = 0 ACK = 0 seq = s1 + 1 ack = s2 +1 > 		established（连接已经建立）

		双方会交换确认一些信息：MSS、是否支持SACK、Window scale（窗口缩放系数）（放在首部可选项部分中）

		为什么建立连接的时候需要3次握手，2次不行？
		1.主要目的是防止server一直等待，浪费资源
		2.如果建立连接的时候只需要2次握手，可能会出现
			client发出第一个连接请求报文段，因为网络延迟，在连接释放后才达到server，server会向client发出确认报文，同意建立连接。如果不采用3次握手，server只要发出确认，新的连接就会建立。由于现在client并没有真正想连接服务器的意愿，因此不会理睬server的确认，也不会向server发送数据。

		第3次握手失败了，会怎么处理？
		1.此时server的状态为syn-rcvd，若等不到client的ACK，server会重新发送SYN+ACK包
		2.如果server多次重发SYN+ACK都等不到client的ACK，就回发送RST包，强制关闭连接。


		释放链接-4次挥手
				客户端 																			服务端
				established（连接已经建立）	>FIN = 1,ACK = 1,seq = u,ack = v>连接释放			established（连接已经建立）
				fin-wait-1（终止等待1）		<FIN = 0,ACK = 1,seq = v,ack = u+1<确认		    	close-wait（关闭等待）
				fin-wait-2（终止等待2）		<FIN = 1,ACK = 1,seq = w,ack = u+1<连接释放			last-ack（最后确认）
				time-wait（时间等待）			>FIN = 0,ACK = 1,seq = u+1,ack = w+1>确认
				close（关闭） 																		close（关闭）

			为什么释放连接需要4次挥手？
			1.TCP是全双工模式，第1次挥手：当主机1发出FIN报文段时，表示主机1告诉主机2，主机1已经没有数据要发送了，但是主机1还是可以接受来自主机2的数据
							 第2次挥手：当主机2返回ACK报文时，表明主机2已经知道主机1没有数据发送了，但是主机2还是可以发送数据给主机1的
							 第3次挥手：当主机2也发送了FIN报文段时，表示主机2告诉主机1，主机1没有数据要发送
							 第4次挥手：当主机1返回ACK报文时，表示主机1已经知道主机2没有数据发送，随后正式断开TCP连接。

			TCP/IP协议栈在设计上，允许任何一方先发起断开请求。
			Client发送ACK后，需要有个TIME-Wait阶段，等待一段时间后，再真正关闭连接。一般是等待2倍的MSL（Maximun Segment Lifetime，最大分段生存期，大概2分钟）。
			如果Client发送ACK后马上释放了，然后又因为网络原因，server没有收到client的ACK，server就回重发FIN，可能Client没有任何响应，服务器干等，甚至多次重发Fin，浪费资源。client有个新的应用程序刚好分配了同一个端口号，新的应用程序收到FIN后马上开始执行断开连接的操作，本来它可能是想跟server建立连接的。

			三次挥手的情况
			当server收到client的FIN时，server已经没有数据要发送给client，server就回将2、3次挥手合并，同时告诉client两件事：1.已经知道client没有数据要发2.server已经没有数据要发。
	

	# 应用层
		应用层的常见协议：
		超文本传输：HTTP、HTTPS
		文本传输：FTP
		电子邮件：SMTP、POP3、IMAP
		动态主机配置：DHCP
		域名系统：DNS

		域名（Domain Name）
		IP地址不方便记忆，并且不能表达组织的名称和性质，所以设计出了域名。但实际上，为了能够访问具体的主机，最终还是得知道目标主机的IP地址。

		为什么直接用域名，不用IP地址？
		IP地址固定4字节，域名使用字节多，会给路由器增加流量负担，增加流量。

		根据级别不同，域名可以分为：
		1.顶级域名：.com(公司)，.net（网络机构），.org（组织机构），.edu（教育），.gov（政府部门），.int（国际组织），.cn（中国），.jp（日本），.uk（英国），.vip，.xyz，.top，.club，.shop等
		2.二级域名：在通用定级域名下，一般指注册人的名称，例如google，baidu，microsoft，在国际级顶级域名下，一般指注册级别
		3.三级域名

		DNS（Domain Name System）域名系统
		利用DNS协议，将域名解析成对应的IP地址，DNS服务器可以基于UDP，也可以基于UDP，服务器占用53端口
		->本地名称服务器->根名称服务器->顶级名称服务器->二级名称服务器->权威名称服务器
		1.客户端会先访问最近的一台DNS服务器（客户端自己配的DNS服务器）
		2.所有的DNS服务器都记录了DNS根域名服务器端IP地址
		3.上级DNS服务器记录了下一级DNS服务器的IP地址
		4.全球一共13台IPV4的DNS根域名服务器，25台IPV6DNS根域名服务器

		IP地址的分配
		IP地址按照分配的方式，可以分为：静态IP地址、动态IP地址
		静态IP地址：
			手动设置
			适用场景：不怎么挪动的台式机，服务器
		动态IP地址：
			从DHCP服务器自动获取IP地址
			适用场景：移动设备，无线设备
			DHCP（Dynamic Host Configuration Protocol）：动态主机配置协议
				DHCP协议基于UDP协议，客户端是68端口，服务器上67端口。DHCP服务器会从IP地址池中，挑选一个IP地址出租给客户端一段时间，时间到期就回收他们。
				DHCP分配地址的4个阶段：
					1.Discover：发现服务器。发广播包（源0.0.0.0,目标IP是255.255.255.255，目标mac是FF:FF:FF:FF:FF:FF）
					2.Offer:提供租约。服务器返回可以租用的IP地址，以及租用期限，子网掩码，网管，DNS等信息。这里可能会有多个服务器提供租约
					3.Request:选择IP地址。客户端选择一个Offer，发送广播包进行回应。
					4.Acknowledge：确认。被选中的服务端发送ACK数据包给客户端。至此，IP地址分配完毕
				DHCP服务器可以跨网段分配IP地址（DHCP服务器、客户端不在同一个网段），可以借助DHCP中继代理（DHCP Relay Agent）实现跨网段分配IP地址
				自动续约：客户端毁在租期不足的时候，自动向DHCP服务器发送Request信息申请续约


		HTTP（Hyper Text Transfer Protocol）超文本传输协议 
		是互联网中应用最广泛的应用层协议之一
		设计HTTP最初的目的是：提供一种发布和接收HTML页面的方法，由URI来识别具体资源。
		用HTTP传递的数据格式不仅仅是HTML，应用非常广泛 

		HTML（Hyper Text Markup Language）超文本标记语言
		用以编写网页

		HTTP版本：
			HTTP/0.9(1991)
			只支持Get请求方法获取文本数据（比如HTML文档），且不支持请求头，响应头，无法向服务器传递太多信息

			HTTP/1.0(1996)
			支持Post，Head等请求方法，支持请求头，响应头，支持跟多数据类型，浏览器的每次i请求都需要与服务器建立一个TCP连接，请求处理完成后立即断开TCP连接

			HTTP/1.1(1997)
			支持PUT、DELETE等请求方法
			采用持久连接（Connection：keep-alive），多个请求可以共用一个TCP连接

			HTTP/2.0(2015)

			HTTP/3.0(2018)

		请求报文：
		方法【】URL【】版本【回车换行】
		首部字段名：【】值【回车换行】
		首部字段名：【】值【回车换行】
		【回车换行】

		响应报文：
		版本【】状态码【】短语【回车换行】
		首部字段名：【】值【回车换行】
		首部字段名：【】值【回车换行】
		【回车换行】

		ABNF：是BNF的修改、增强版，是最严谨的HTTP报文格式描述形式，脱离ABNF谈HTTP报文格式都是不严谨的
		HTTP-message = start-line 			start-line = request-line/status-line
		*(header-field CRLF)
		CRLF
		[message-body]
		/ ： 任选一个
		* ： 0个或者多个，2*标识至少2个
		()： 组成一个
		[]： 可选（可有可无）

		request-line = method SP request-target SP HTTP-version CRLF
		HTTP-version = HTTP-name "/" DIGIT "." DIGIT
		HTTP-name = %x48,54,54,50;HTTP
		status-line = HTTP-version SP status-code SP reason-phrase CRLF
		status-code = 3 DIGIT
		reason-phrase = *(HTAB/SP/VCHAR/obs-text)
		header-field = field-name ":" OWS field-value OWS
		field-name = token
		field-value = *(field-content / obs-fold)
		OWS = *(SP / HTAB)
		message-body = *OCTET

		URL的编码
			URL中一旦出现一些特殊字符（比如中文、空格）需要进行编码，在浏览器地址输入URL时，是采用UTF-8进行编码
		
		请求方法
			GET：常用于读取操作，请求参数直接拼接在URL的后面（浏览器对URL的有长度限制的）
			HEAD：与GET请求得到相同的响应，但是没有响应体（在下载一个大文件前，先获取大小，再决定是否要下载，以此可以节约带宽资源）
			POST：常用于添加、修改、删除的操作，请求参数可以放到请求体中（没有大小限制）
			PUT：用于已存在的资源进行整体覆盖
			DELETE：删除指定的资源
			CONNECT：可以开启一个客户端与所请求资源之间的双向沟通的通道，可以用来创建隧道，用以访问采用SSL（HTTPS）协议的站点
			OPTIONS：可以获取目的资源所支持的通信选项，不如服务器支持的请求方法
			TRACE：请求服务器回显其收到的请求信息，主要用于HTTP请求的测试或者诊断
			PATCH：用于对资源进行部分修改（资源不存在或创建新的资源）

		头部字段-header-field 
			请求头字段：要获取的资源或者客户端本身信息的消息头
				User-agent 					浏览器的身份识别字符串 					User-Agent:Mozilla/5.0(X11;Linux x86_64; rv:12.0)Gecko/20100101 Firefox/21.0
				Host						服务器端域名、端口号						Host: localhost:8080
				Date						发送该消息的日期和时间						Date: Tue, 15 Nov 1994 09:12:13
				Referer					表示浏览器所访问的前一个页面，正式那个页面上的某个连接将浏览器带到了当前请求的界面 Referer: Https://www.baidu.com
				Content-Type				请求体的类型								Content-Type : multipart/form-data
				Content-Length  			请求体的长度（字节为单位）					Content-Lenth: 348
				Accept 						接收的响应内容类型							Accept: text/plain
				Accept-Charset				能接受的字符集							Accept-Cahrset: utf-8
				Accept-Encoding				能接受的编码方式列表 						Accept-Encoding: gzip,deflate
				Accept-Language				能接受的响应内容的自然语言列表 				Accept-Language: en-US
				Range						仅请求某个实体店一部分，字节偏移0开始  		Range: bytes=500-999
				Origin						发起一个针对跨域资源共享的请求				Origin: https://www.baidu.com
				Cookie						之前由于服务器通过Set-Cookie发送的Cookie 	Cookie: $Version=1;Skin=new
				Connection 					该浏览器想要优先使用的连接类型 				Connection: keep-alive
				Cache-Control				指定这次请求/响应中所有缓存机制遵守的指令	Cache-Control: no-cache
				Date 						发送该消息的日期和时间 					Date: Tue, 15 Nov 1994 08:12:31 GMT
				Last-Modified				请求的对象的最后修改时间					Last-Modified: Tue, 13 Nov 1994 08:12:31 GMT
				Server 						服务器端名字 								Server: Apache/2.4.1(Unix)
				Expires 					指定一个时间，超过该时间则认为此响应已经过期	Expires: Thu, 01 Dec 1994 15:00:00 GMT
			响应头字段：响应的补充信息，比如服务器本身（名字和版本的消息头）
				Content-Type				响应体的类型								Content-Type: text/html;charset=utf-8
				Content-Encoding			内容所使用的编码类型						Content-Encoding: gzip
				Content-Length				响应体的长度（字节为单位）					Content-Length: 368
				Content-Disposition			一个可以让客户端下载文件并建议文件名的头部	Content-Disposition: attachment;filename="fname.txt"
				Accept-Ranges				服务器支持哪些种类的部分内容范围 			Accept-Ranges: bytes
				Content-Range				该消息属于完整消息的哪部分					Content-Range: bytes 21010-47021/47022

			实体头字段：实体主体的更多信息，比如主题长度
			通用头字段：同时适用请求和响应消息，但与消息主体无关的消息头


		状态码
			指HTTP请求是否成功完成
			信息响应：100-199 
				100 Continue：请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应码。允许客户端发送带请求提的请求之前，判断服务器是否愿意接收请求。如果服务器在不看请求提就拒绝请求时，客户端发送请求是不恰当或者低效的。
			成功响应：200-299
			 	200 OK：请求成功
			重定向：300-399
				302 Found：请求的资源被暂时移动到了由Location头部指定的URL上
				304 Not Modified：说明无需再次传输请求的内容，也就是说可以使用缓存的内容
			客户端错误：400-499
				400 Bad Request：由于语法无效，服务器无法理解请求
				401 Unauthorized: 由于缺乏目标资源要求的身份验证凭证
				403 Forbidden：服务器有能力处理该请求，但是拒绝授权访问
				404 Not Found：服务器无法找到所请求的资源
				405 Method Not Allowed：服务器禁止使用当前HTTP方法的请求
				406 Not Acceptable：服务器无法提供与Accept-Charset以及Accept-Language指定的值相匹配的响应
				408 Request-Timeout：服务器想要将没有在使用的连接关闭。
			服务端错误：500-599
				500 Internal Server Error：所请求的服务器遇到意外的情况并阻止其执行请求
				501 Not Implemented： 请求的方法不被服务器支持，因此无法被处理
				502 Bad Getway：作为网管或者代理角色的服务器，从上游服务器中接受到响应是无效的
				503 Service Unavailable：服务器尚未处于可以接受请求的状态（宕机或者超载）


		form提交-常用属性
			action：请求的URL
			method：请求方法（GET、POST）
			enctype：POST请求时，请求体的编码格式。application/x-www-form-urlencoded 用&分隔参数，用=分隔键和值，字符用URL编码方式进行编码
			multipart/form-data：文件上传时必须使用这种编码方式


		同源策略
			默认情况下，AJAX请求只能发送给同源的URL（同源：协议、域名、端口 ）
				Access-Control-Allow-Origin：指定哪些网站可参与ao跨来源资源共享过程中
			img、script、link、iframe、video、audio等标签不收同源策源的约束

		Cookie的作用于
			domain和path标识定义了Cookie的作用于，即Cookie应该发送给哪些URL
			domain
				标识了哪些主机可以接受Cookie
				如果不指定，默认位当前文档的主机，如果指定了domain，则一般包含子域名，如domain=520it.com，则Cookie包含bbs.520it.com
			path
				标识制订了主机下哪些路径可以接受Cookie，子路径也会被匹配
				例如path=/docs，则以下地址都会匹配：/docs  /docs/one/ /docs/one/img

		代理服务器（proxy Server）
			特点：本身不生产内容，处于中间位置转发上下游的请求和响应
				面向下游的客户端，它是服务器
				面向上游的服务器，他是客户端
			正向代理：代理的对象是服务器
				隐藏客户端身份
				绕过防火墙（突破访问限制）
				Internet访问控制
				数据过滤
			反向代理：代理的对象是客户端
				隐藏服务器身份
				安全防护
				负载均衡
			相关的头部字段：
				Via：追加经过的每一台代理服务器的主机名（或域名）
				X-forwarded-For：追加请求放的IP地址
				X-Real-IP：客户端的真实IP地址

		抓包工具的原理
			Fiddler，Charles等抓包工具的原理：在客户端启动了正向代理服务
			Wireshark的原理：通过底层驱动，拦截网卡上流过的数据

		CDN（Content Delivery Network或Content Distribution Network）内容分发网络
			利用最靠近每位用户的服务器，更快更可靠得将音乐、图片视频等资源文件传递给用户
			CDN运营商在全国各大城市都建立了机房，部署了大量拥有高存储高带宽的节点，构建了一个跨运营商、跨地狱的专用网络
			内容所有者向CDN运营商支付费用，CDN将内容交付给最终用户

		### 网络安全
		网络通信中面临的4中安全威胁
			1.截取：窃听通信内容
			2.中断：中断网络通信
			3.篡改：篡改通信内容
			4.伪造：伪造通信内容

		ARP
			ARP欺骗，又称ARP毒花、病毒、攻击，可以让攻击者获取局域网上的数据甚至可以篡改数据包，让网络上特定电脑之间无法通信，导致送至特定IP地址的流量被错误送到攻击者所取代的地方。
				C是攻击者，AB是被攻击者，C只要收到过A、B发送的ARP请求，就会拥有A、B的IP、Mac地址，就可以进行欺骗活动。
				1.C发送一个ARP响应给B，把响应包里面的源IP设为A的IP地址，源MAC地址设为C的MAC地址
				2.B收到ARP响应后，更新它的ARP表，把A的MAC地址（IP_A, MAC_A）改为（IP_A, MAC_C）
				3.当B要发送数据包给A时，它根据ARP表来封装数据包的头部，把目标MAC地址设为MAC_C，而非MAC_A 
				4.当交换机收到B发送给A的数据包时，根据此包的目标MAC地址（MAC_C）而把数据包转发给C 
				5.C收到数据包后，可以把它存起来后再发送给A，达到窃听效果。C也可以篡改数据后才发送数据包给A
			ARP防护
				1.静态ARP
				2.DHCP Snooping，网络这杯可借由DHCP保留网络上各电脑的MAC地址，在伪造的ARP数据包发送时即可侦测

		Dos，DDos
			Dos攻击（Denial-of-Service attack）使目标电脑的网络或系统资源耗尽，使服务暂时中断或者停止，导致其他正常用户无法访问
			DDos工具（）Distributed Denial-of-Service attack）使用网络上两个或以上被攻陷的电脑作为僵尸向特定的目标发动Dos攻击
				带宽消耗型：
					UDP洪水攻击、
					ICMP洪水攻击
				资源消耗型：
					SYN洪水攻击：攻击者发送一系列的SYN请求到目标，然后让目标因收不到ACK而进行等待、消耗资源（跳过发送最后的ACK信息，修改源IP地址，让目标发送SYN-ACK到伪造的IP地址，因此目标永不可能收到ACK）
					LAND洪水攻击：局域网拒绝服务攻击，通过持续发送相同源地址和目标地址的欺骗数据包，使目标视图与自己建立联系，消耗资源系统直至崩溃。 
			DOS、DDos防御
				入侵检测、流量过滤、多重验证，堵塞网络贷款的流量将被过滤，而正常的流量可正常通过。
				防火墙
					防火墙可以设置规则，例如允许或者拒绝特定通讯协议，端口或者IP地址
					当攻击从少数不正常的IP地址发出时，可以简单的使用拒绝规则组织一切从攻击源IP发出的通信。
					复杂攻击难以用简单规则来阻止，例如80端口遭受攻击时不可能拒绝端口所有的通信，因为同时会阻止合法流量
					防火墙可能处于网络架构中过后的位置，路由器可能在恶意流量达到防火墙前即被攻击影响。
				交换机：大多数交换机有一定的速度限制和访问控制能力
				路由器：和交换机类似，有一定的速度显示和访问控制能力
				黑洞引导：将所有受攻击计算机的通信全部发送至一个黑洞（空接口或者不存在的计算机地址）或者足够能力处理洪流的网络设备商
				流量清晰：当流量被送到DDos防护清洗中心时，通过采用抗DDos软件处理，将正常流量和异常流量分开


		应用层-DNS劫持（域名劫持）   
			攻击或者篡改了某个域名的解析结果，使得指向该域名的IP变成了另一个IP，导致对相应网址的访问被劫持到另一个不可达的或者假冒的网站，从而实现非法窃取用户信息或者破坏正常还忘了服务器目的
			防止DNS劫持，可以考虑使用更靠谱的DNS服务器，比如：114.114.114.114
			HTTP劫持：对HTTP数据包进行连接处理，比如插入JS代码。

























