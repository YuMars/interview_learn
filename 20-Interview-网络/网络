网络

网络互连模型

OSI参考模型（7层）（Open System Interconnect Reference Model）
应用层
表示层
会话层
运输层
网络层
链路层
物理层

TCP/IP协议（4层）
应用层（应用层、表示层、会话层）
运输层
网际层（网络层）
网络接口层（数据链路层、物理层）

学习研究（5层）
应用层（应用层、表示层、会话层） （报文）       HTTP-1.1-GET       				 FTP、HTTP、SMTP、DNS、DHCP  
运输层 						 （段Segments） TCP头：包含端口号、序列号				 TCP、UDP
网际层（网络层）				 （包Packets）  IP头：包含IP地址-目标IP地址-源IP地址-协议（ICMP=1、TCP=6、UDP=17） IP、ARP、ICMP
数据链路层 					 （帧frames）   以太网头：包含Mac地址-以太网相关信息              CSMA/CD、PPP
物理层  						 （比特流bits）

分层的好处：
	1.各层独立:限制了依赖关系的范围，各层之间使用标准化的接口，各层不需要知道山西盖层是如何工作的，增加或者修改一个应用层协议不会影响传输层协议。
	2.灵活性更好：比如路由器不需要应用层和传输层，分层以后路由器就可以只需加载更少的几个协议层
	3.易于测试和维护：提高了可测试性，可以独立的测试特定层，某一层有了更好的实现可以整体替换掉
	4.能促进标准化：每一层职测清楚，方便进行标准化



# 物理层：定义了接口标准、线缆标准、传输速率、传输方式等
	模拟信号：
	1.连续的信号，适合长距离传输
	2.抗干扰能力差，收到干扰时波形变形很难纠正

	数字信号：
	1.离散的信号，不适合长距离传输
	2.抗干扰能力强，收到干扰时波形失真可修复

	数据通信模型
		局域网
		PC ----数字信号（网线）---- 交换机 -----数字信号（网线）------ PC

		广域网
		PC ----数字信号（网线）---- 调制解调器 ----- 模拟信号（电话线）----- 调制解调器 ----- 数字信号（网线）------ PC

	信道（Channel）
		信息传输的通道，一条传输介质上（比如网线）可以有多条信道
		单工通信：信号只能往一个放线传输，任何时候都不能改变信号的传输反向（无线电广播）
		半双工通信：信号可以双向传输，但是必须交通通行（对讲机）
		全双工通信：信号可以同时双向传输（手机）

# 数据链路层：
	链路：从一个节点到相邻节点的一段物理线路，中间没有其他交换节点
	数据链路：在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输。不同类型的数据链路，通信协议可能不同。
		广播信道：CSMA/CD协议（不如同轴电缆，集线器等组成的网络）
		点对点信道：PPP协议（比如路由器之间的信道）
	数据链路的3个基本问题：
		1.封装成帧
			帧的数据部分：网络层传递下来的数据包（IP数据包）
			最大传输单元：每一种数据链路协议都规定了所能够传输的帧的数据长度上限，以太网的最大传输单元1500字节
		2.透明传输
			数据部分一旦出现SOH、EOT需要进行转义（用ESC填充）
		3.差错检验
			FCS：根据数据部分+首部计算得出

	CSMA/CD协议
		1.载波侦听多路访问/冲突检测
		使用率CSMA/CS的网络可以成为以太网，它传输的是以太网帧
			以太网帧的格式有：Ethernet V2标准、IEEE的802.3标准
			使用最多的是：Ethernet V2标准
		为了能够检测正在发送的真是否产生冲突，以太网的帧至少要64字节

		用交换机组件的网络，已经支持全双工通信，不需要再使用CSMA/CD，但它传输的帧依然是以太网帧，所以交换机组件网络，依然可以叫做以太网

	Ethernet V2帧 
																								IP层
						6 		 6        2        					46-1500	         	4
					目标Mac地址-源Mac地址-类型（IPV6、IPV4）--------数据（IP数据包）-------FCS 		MAC层
				8字节|						以太网Mac帧	  					|       			物理层
前同步码7 ---帧开始定界符1----												没有帧结束符

	首部：源MAC地址+目标MAC地址+网络类型
	以太网帧：首部+收据+FCS
	数据的长度至少是：64-6-6-2-4=46

	当数据部分的长度小于46字节时：1.数据链路层会在数据的后面加入一些字节填充2.接收端会将添加的字节去掉
	长度总结：以太网帧的数据长度46-1500 以太网帧的长度：64-1518（源Mac地址+目标MAC地址+网络类型+数据+FCS）

	PPP协议（Point to Point Potocol）

			| 	      首部	   		  |
			F  ---- A ---- C ---- 协议 ---- 信息部分 ---- FCS ---- F
	字节数   1       1      1       2     不 超过1500字节  2       1
 

# 网络层
	网络层数据包（IP数据包，Packet）由首部、数据2部分组成
	数据：很多时候是有传输层传递下来的数据段

			|                  32位					|
	——————	版本 --- 首部长度 --- 区分服务 ---   总长度
	首部		标识 --- 标志 --- 片偏移
	20字节	生存时间 --- 协议 --- 首部检验和
			源IP地址
	——————	目标IP地址
			可选字段（长度可变） --- 填充
			数据部分（最大1460）
			|  			总长度65535位				|

	版本：占4位 IPV6、IPV4
	首部长度：占4位，二进制乘以4才是最终长度，20最小值，60最大值
	区分服务：(QOS)占8位，可以用于提高网络质量
	总长度：占16位 首部+数据的长度之和，最大值是65535。
		由于帧的数据不能超过1500字节，所以过大的IP数据包，需要分成片传输给数据链路层
		每一篇都有自己的网络层首部
	标识：占16位，数据包的ID，当数据包过大进行分片时，同一个数据包的所有片的标识都一样，有一个计数器专门管理数据包的ID，每发出一个数据包，ID就+1
	标志：占3位，第一位：（Reserved bit）保留。第二位：（Don't Fragment）1代表不允许分片，0代表允许。第三位：（More fragments）1代表不是最右一片，0代表是最后1片。··
	片偏移：占13位，片偏移乘以8=字节偏移，每一片段长度一定是8的整数倍 
	生存时间（TTL）：占8位，每个路由器在转发之前会将TTL减1，一旦发现TTL减为0，路由器会返回错误报告。观察使用ping命令后的TTL，能够推测出对方的操作系统，中间经历了多少个路由器
		Window： 128
		Linux：64（255）
		Mac OS：60
		Mac OS X：64 


# 传输层（TCP：Transmission Control Protocol）
	传输层有两个协议：1.TCP，传输控制协议
					2.UDP（User Datagram Protocol），用户数据报协议
								 		TCP 									UDP
		连接性						面向链接									无连接
		可靠性						可靠传输，不丢包							不可靠传输，尽最大努力交付，可能丢包
		首部占用空间					大 											小
		传输速率  					慢 											快
		资源消耗						大 											小
		应用场景						浏览器、文件传输、邮件发送 						音视频通话、直播
		应用层协议					HTTP、HTTPS、FTP、SMTP、DNS					DNS


	UDP
	UDP是无连接，减少了建立和释放链接的开销
	UDP尽最大能力交付，不保证可靠交付，隐藏不需要维护一些复杂的参数，首部只有8个字节（TCP首部至少20字节）
	UDP长度：占16位，首部的长度+数据的长度
													 ————————	
				16位源端口号 				16位目标端口号  |  
				16位UDP长度				16位UDP检验和  8字节
				数据 								 ————————
	检验和：计算内容=伪首部+首部+数据
			伪首部：源IP地址、目标IP地址、0（保留）、17（协议）、UDP长度 
			首部：源端口、目标端口、长度、检验和
	端口：占16位，可以推测出端口号的取值范围是0-65535，客户端的端口是临时开启的随机端口，防火墙可以设置开启、关闭某些端口提高安全性
		netstat -an:查看被占用的端口
		netstat -anb：查看被占用的端口、占用端口的应用程序
		telnet 主机 端口：查看市口可以访问主机的 某个端口


	TCP
	| 								16字节								|			16字节					|	
	----	源端口  																目标端口
			序列号
	20字节	确认号
			数据偏移	 	保留（flags） URG  ACK   PSH   RST   SYN   FIN   		窗口大小
	----	检验和    															紧急指针
			选项（长度可变） 														填充
 
 	序列号：占4字节。传输过程的每一个字节都会有一个编号，在建立连接后，序号代表：这一次传给对方的TCP数据部分的第一个字节的编码
 	确认号：占4字节。在建立连接后，确认号代表：期望对方下一次传过来的TCP数据部分的第一个字节的编号 
 	窗口：占2字节，这个字段有流量控制功能，能以告知对方下一次允许发送的数据大小（字节为单位）
	数据偏移：占4位，取值范围0x0101-0x1111，数据便宜乘以4=首部长度

			 UDP首部中占16位的长度字段是冗余的，纯粹是为了保证首部是32bit对齐
			 TCP/IP的数据长度，完全可以由IP数据包的首部推测出来
			 传输层的数据长度=网络层的总长度-网络层首部的长度-传输层首部的长度
	检验和： 伪首部+首部+数据
			伪首部：占用12字节，仅在计算检验和时起作用，并不会传递给网络层
	URG：（Urgent） 当URG = 1时，紧急指针字段才有效。表明当前报文段中有紧急数据，应优先尽快传递
	ACK：（Acknowledge） 当ACK = 1时，确认号字段才有效
	PSH：（Push）
	RST：（Reset） 当RST = 1时，表明连接中出现严重差错，必须释放连接，然后重新建立链接。
	SYN：（Synchroinzation） 当SYN = 1，ACK = 0时，表示这是一个建立链接的请求，若对方同意建立链接，则恢复SNY = 1，ACK = 1
	Fin：（Finish） 当Finsh = 1时，表明数据已经发送完毕，要求释放连接

	可靠传输：
		ARQ：Automatic Repeat-request，自动重传请求
		停止等待ARQ协议：等收到确认消息后再发送新的数据
		连续ARQ协议+滑动窗口协议： 如果接收窗口最多能接收4个包，但发送发只发了2个包，接受方等到一定时间后没收到第3个包，就回返回确认收到第2个包
		SACK（选择性确认）：
			1.在TCP通信过程中，如果发送序列中间某个数据包丢失（1、2、3、4、5丢了3），TCP会通过重传最后确认的分组后续的分组（最后确认2，所以重传3、4、5），这样原先已经正确传输的分组也可能重复发送，降低了TCP性能。为了改善上述情况，发展除了SACK（Selective Acknowledgment），告诉发送方哪些数据丢失，哪些数据已经收到。使用TCP只重新发送（3），不用发送的后续分组（4、5）。
			2.SACK信息会放在TCP首部的可选部分。Kind占一个字节 = 5，Length占一个字节，表明SACK一共占用多少字节。Left Edge：占4字节，左边界。Right Edge：占4字节，右边界。一堆边界信息需要占用8字节，由于TCP首部的选项部分最多40字节，所以SACK选项最多携带4组边界信息，SACK选项的最大占用字节数 = 4 * 8+2 = 34
		

	流量控制：
		如果接收方的缓存区满了，发送方还在发送数据，接收方只能把收到的数据包丢掉，大量的丢包会浪费网络资源，所以需要进行流量控制。
		什么是流量控制？让发送方的发送速率不要太快，让接收方来得及接收处理。
		原理：通过确认报文中窗口字段来控制发送方的发送速率，发送方的窗口大小不能超过接收方给出的窗口大小，当发送方收到的接收窗口大小为0时，发送方就回停止发送数据。

		特殊情况：开始接收方给发送方发送了0窗口的报文段，后面接收方有一些接收空间了，给发送方发送的非0窗口报文段丢失，发送方的发送窗口一直为0，双方陷入僵局
		解决方案：当发送方收到0窗口通知时，发送方停止发送报文，并且通知开启一个定时器，隔一段时间就发个测试报文去询问接收方最新的窗口大小，如果接收到窗口大小还是0，则发送方再次刷新启动定时器。


	拥塞控制：
		防止过多的数据注入到网络中，避免网络中的路由器或者链路过载。
		拥塞控制是一个全局性的过程，涉及到所有的主机、路由器以及与降低网络传输性能有关的所有因素，相比而已流量控制是点对点通信的控制。

		慢开始（slow start）：cwnd的初始值比较小，然后随着数据包被接收方确认，cwnd就成倍增长
		拥塞避免（congestion avoidance）：拥塞窗口缓慢增大，以防止网络过早出现拥塞，只要网络出现拥塞，把ssthresh减半，同时执行慢开始算法
		快速重传（fast retransmit）：接收方每收到一个失序的分组后就立即发出重复确认，使发送方及时知道有分组没有达到，而不要等待自己发送数据时才确认。发送方只要连续收到3个重复确认（总共4个相同的确认），就应该立即重传对方尚未收到的报文段，而不必继续等待重传计时器到后期再重传。
		快速恢复（fast recovery）：当发送方连续收到3个重复确认，就执行乘法减小算法，把ssthresh减半，与慢开始不同之处是现在不执行慢开始算法，即swnd现在不恢复到初始值二十吧cwnd设置为sshthresh减半后的值，然后开始执行拥塞避免算法，使拥塞窗口缓慢线性增大。
			MSS（Max Segment Size）：每个段最大的数据部分大小
			cwnd（congestion window）：拥塞窗口
			rwnd（receive window）：接收窗口
			swnd（send window）：发送窗口
			ssthresh（slow start threshold）：慢开始阈值，cwnd达到阈值后，以线性方式增加。





	连接管理： 
		确认号、序号
	 		---- SYN = 1 ACK = 0 seq = s1     ack = 0      --->
	 client	<--- SYN = 1 ACK = 1 seq = s2     ack = s1 + 1 ----	server
	 		---- SYN = 0 ACK = 0 seq = s1 + 1 ack = s2 +1  --->

	 	建立连接-3次握手
	 			客户端 																		服务端
	 			closed（关闭）  			> SYN = 1 ACK = 0 seq = s1     ack = 0 1 > 			listen(监听)
	 			syn-send（同步已发送）    < SYN = 1 ACK = 1 seq = s2     ack = s1 + 1 <		syn-rcvd（同步已接收）
				established（连接已经建立）> SYN = 0 ACK = 0 seq = s1 + 1 ack = s2 +1 > 		established（连接已经建立）

		双方会交换确认一些信息：MSS、是否支持SACK、Window scale（窗口缩放系数）（放在首部可选项部分中）

		为什么建立连接的时候需要3次握手，2次不行？
		1.主要目的是防止server一直等待，浪费资源
		2.如果建立连接的时候只需要2次握手，可能会出现
			client发出第一个连接请求报文段，因为网络延迟，在连接释放后才达到server，server会向client发出确认报文，同意建立连接。如果不采用3次握手，server只要发出确认，新的连接就会建立。由于现在client并没有真正想连接服务器的意愿，因此不会理睬server的确认，也不会向server发送数据。

		第3次握手失败了，会怎么处理？
		1.此时server的状态为syn-rcvd，若等不到client的ACK，server会重新发送SYN+ACK包
		2.如果server多次重发SYN+ACK都等不到client的ACK，就回发送RST包，强制关闭连接。


		释放链接-4次挥手
				客户端 																			服务端
				established（连接已经建立）	>FIN = 1,ACK = 1,seq = u,ack = v>连接释放			established（连接已经建立）
				fin-wait-1（终止等待1）		<FIN = 0,ACK = 1,seq = v,ack = u+1<确认		    	close-wait（关闭等待）
				fin-wait-2（终止等待2）		<FIN = 1,ACK = 1,seq = w,ack = u+1<连接释放			last-ack（最后确认）
				time-wait（时间等待）			>FIN = 0,ACK = 1,seq = u+1,ack = w+1>确认
				close（关闭） 																		close（关闭）

			为什么释放连接需要4次挥手？
			1.TCP是全双工模式，第1次挥手：当主机1发出FIN报文段时，表示主机1告诉主机2，主机1已经没有数据要发送了，但是主机1还是可以接受来自主机2的数据
							 第2次挥手：当主机2返回ACK报文时，表明主机2已经知道主机1没有数据发送了，但是主机2还是可以发送数据给主机1的
							 第3次挥手：当主机2也发送了FIN报文段时，表示主机2告诉主机1，主机1没有数据要发送
							 第4次挥手：当主机1返回ACK报文时，表示主机1已经知道主机2没有数据发送，随后正式断开TCP连接。

			TCP/IP协议栈在设计上，允许任何一方先发起断开请求。
			Client发送ACK后，需要有个TIME-Wait阶段，等待一段时间后，再真正关闭连接。一般是等待2倍的MSL（Maximun Segment Lifetime，最大分段生存期，大概2分钟）。
			如果Client发送ACK后马上释放了，然后又因为网络原因，server没有收到client的ACK，server就回重发FIN，可能Client没有任何响应，服务器干等，甚至多次重发Fin，浪费资源。client有个新的应用程序刚好分配了同一个端口号，新的应用程序收到FIN后马上开始执行断开连接的操作，本来它可能是想跟server建立连接的。

			三次挥手的情况
			当server收到client的FIN时，server已经没有数据要发送给client，server就回将2、3次挥手合并，同时告诉client两件事：1.已经知道client没有数据要发2.server已经没有数据要发。
	

	# 应用层
		应用层的常见协议：
		超文本传输：HTTP、HTTPS
		文本传输：FTP
		电子邮件：SMTP、POP3、IMAP
		动态主机配置：DHCP
		域名系统：DNS

		域名（Domain Name）
		IP地址不方便记忆，并且不能表达组织的名称和性质，所以设计出了域名。但实际上，为了能够访问具体的主机，最终还是得知道目标主机的IP地址。

		为什么直接用域名，不用IP地址？
		IP地址固定4字节，域名使用字节多，会给路由器增加流量负担，增加流量。

		根据级别不同，域名可以分为：
		1.顶级域名：.com(公司)，.net（网络机构），.org（组织机构），.edu（教育），.gov（政府部门），.int（国际组织），.cn（中国），.jp（日本），.uk（英国），.vip，.xyz，.top，.club，.shop等
		2.二级域名：在通用定级域名下，一般指注册人的名称，例如google，baidu，microsoft，在国际级顶级域名下，一般指注册级别
		3.三级域名

		DNS（Domain Name System）域名系统
		利用DNS协议，将域名解析成对应的IP地址，DNS服务器可以基于UDP，也可以基于UDP，服务器占用53端口
		->本地名称服务器->根名称服务器->顶级名称服务器->二级名称服务器->权威名称服务器
		1.客户端会先访问最近的一台DNS服务器（客户端自己配的DNS服务器）
		2.所有的DNS服务器都记录了DNS根域名服务器端IP地址
		3.上级DNS服务器记录了下一级DNS服务器的IP地址
		4.全球一共13台IPV4的DNS根域名服务器，25台IPV6DNS根域名服务器

		IP地址的分配
		IP地址按照分配的方式，可以分为：静态IP地址、动态IP地址
		静态IP地址：
			手动设置
			适用场景：不怎么挪动的台式机，服务器
		动态IP地址：
			从DHCP服务器自动获取IP地址
			适用场景：移动设备，无线设备
			DHCP（Dynamic Host Configuration Protocol）：动态主机配置协议
				DHCP协议基于UDP协议，客户端是68端口，服务器上67端口。DHCP服务器会从IP地址池中，挑选一个IP地址出租给客户端一段时间，时间到期就回收他们。
				DHCP分配地址的4个阶段：
					1.Discover：发现服务器。发广播包（源0.0.0.0,目标IP是255.255.255.255，目标mac是FF:FF:FF:FF:FF:FF）
					2.Offer:提供租约。服务器返回可以租用的IP地址，以及租用期限，子网掩码，网管，DNS等信息。这里可能会有多个服务器提供租约
					3.Request:选择IP地址。客户端选择一个Offer，发送广播包进行回应。
					4.Acknowledge：确认。被选中的服务端发送ACK数据包给客户端。至此，IP地址分配完毕
				DHCP服务器可以跨网段分配IP地址（DHCP服务器、客户端不在同一个网段），可以借助DHCP中继代理（DHCP Relay Agent）实现跨网段分配IP地址
				自动续约：客户端毁在租期不足的时候，自动向DHCP服务器发送Request信息申请续约


		HTTP（Hyper Text Transfer Protocol）超文本传输协议 
		是互联网中应用最广泛的应用层协议之一
		设计HTTP最初的目的是：提供一种发布和接收HTML页面的方法，由URI来识别具体资源。
		用HTTP传递的数据格式不仅仅是HTML，应用非常广泛 

		HTML（Hyper Text Markup Language）超文本标记语言
		用以编写网页

		HTTP版本：
			HTTP/0.9(1991)
			只支持Get请求方法获取文本数据（比如HTML文档），且不支持请求头，响应头，无法向服务器传递太多信息

			HTTP/1.0(1996)
			支持Post，Head等请求方法，支持请求头，响应头，支持跟多数据类型，浏览器的每次i请求都需要与服务器建立一个TCP连接，请求处理完成后立即断开TCP连接

			HTTP/1.1(1997)
			支持PUT、DELETE等请求方法
			采用持久连接（Connection：keep-alive），多个请求可以共用一个TCP连接

			HTTP/2.0(2015)

			HTTP/3.0(2018)

		请求报文：
		方法【】URL【】版本【回车换行】
		首部字段名：【】值【回车换行】
		首部字段名：【】值【回车换行】
		【回车换行】

		响应报文：
		版本【】状态码【】短语【回车换行】
		首部字段名：【】值【回车换行】
		首部字段名：【】值【回车换行】
		【回车换行】

		ABNF：是BNF的修改、增强版，是最严谨的HTTP报文格式描述形式，脱离ABNF谈HTTP报文格式都是不严谨的
		HTTP-message = start-line 			start-line = request-line/status-line
		*(header-field CRLF)
		CRLF
		[message-body]
		/ ： 任选一个
		* ： 0个或者多个，2*标识至少2个
		()： 组成一个
		[]： 可选（可有可无）

		request-line = method SP request-target SP HTTP-version CRLF
		HTTP-version = HTTP-name "/" DIGIT "." DIGIT
		HTTP-name = %x48,54,54,50;HTTP
		status-line = HTTP-version SP status-code SP reason-phrase CRLF
		status-code = 3 DIGIT
		reason-phrase = *(HTAB/SP/VCHAR/obs-text)
		header-field = field-name ":" OWS field-value OWS
		field-name = token
		field-value = *(field-content / obs-fold)
		OWS = *(SP / HTAB)
		message-body = *OCTET

		URL的编码
			URL中一旦出现一些特殊字符（比如中文、空格）需要进行编码，在浏览器地址输入URL时，是采用UTF-8进行编码
		
		请求方法
			GET：常用于读取操作，请求参数直接拼接在URL的后面（浏览器对URL的有长度限制的）
			HEAD：与GET请求得到相同的响应，但是没有响应体（在下载一个大文件前，先获取大小，再决定是否要下载，以此可以节约带宽资源）
			POST：常用于添加、修改、删除的操作，请求参数可以放到请求体中（没有大小限制）
			PUT：用于已存在的资源进行整体覆盖
			DELETE：删除指定的资源
			CONNECT：可以开启一个客户端与所请求资源之间的双向沟通的通道，可以用来创建隧道，用以访问采用SSL（HTTPS）协议的站点
			OPTIONS：可以获取目的资源所支持的通信选项，不如服务器支持的请求方法
			TRACE：请求服务器回显其收到的请求信息，主要用于HTTP请求的测试或者诊断
			PATCH：用于对资源进行部分修改（资源不存在或创建新的资源）

		头部字段-header-field 
			请求头字段：要获取的资源或者客户端本身信息的消息头
				User-agent 					浏览器的身份识别字符串 					User-Agent:Mozilla/5.0(X11;Linux x86_64; rv:12.0)Gecko/20100101 Firefox/21.0
				Host						服务器端域名、端口号						Host: localhost:8080
				Date						发送该消息的日期和时间						Date: Tue, 15 Nov 1994 09:12:13
				Referer					表示浏览器所访问的前一个页面，正式那个页面上的某个连接将浏览器带到了当前请求的界面 Referer: Https://www.baidu.com
				Content-Type				请求体的类型								Content-Type : multipart/form-data
				Content-Length  			请求体的长度（字节为单位）					Content-Lenth: 348
				Accept 						接收的响应内容类型							Accept: text/plain
				Accept-Charset				能接受的字符集							Accept-Cahrset: utf-8
				Accept-Encoding				能接受的编码方式列表 						Accept-Encoding: gzip,deflate
				Accept-Language				能接受的响应内容的自然语言列表 				Accept-Language: en-US
				Range						仅请求某个实体店一部分，字节偏移0开始  		Range: bytes=500-999
				Origin						发起一个针对跨域资源共享的请求				Origin: https://www.baidu.com
				Cookie						之前由于服务器通过Set-Cookie发送的Cookie 	Cookie: $Version=1;Skin=new
				Connection 					该浏览器想要优先使用的连接类型 				Connection: keep-alive
				Cache-Control				指定这次请求/响应中所有缓存机制遵守的指令	Cache-Control: no-cache
				Date 						发送该消息的日期和时间 					Date: Tue, 15 Nov 1994 08:12:31 GMT
				Last-Modified				请求的对象的最后修改时间					Last-Modified: Tue, 13 Nov 1994 08:12:31 GMT
				Server 						服务器端名字 								Server: Apache/2.4.1(Unix)
				Expires 					指定一个时间，超过该时间则认为此响应已经过期	Expires: Thu, 01 Dec 1994 15:00:00 GMT
			响应头字段：响应的补充信息，比如服务器本身（名字和版本的消息头）
				Content-Type				响应体的类型								Content-Type: text/html;charset=utf-8
				Content-Encoding			内容所使用的编码类型						Content-Encoding: gzip
				Content-Length				响应体的长度（字节为单位）					Content-Length: 368
				Content-Disposition			一个可以让客户端下载文件并建议文件名的头部	Content-Disposition: attachment;filename="fname.txt"
				Accept-Ranges				服务器支持哪些种类的部分内容范围 			Accept-Ranges: bytes
				Content-Range				该消息属于完整消息的哪部分					Content-Range: bytes 21010-47021/47022

			实体头字段：实体主体的更多信息，比如主题长度
			通用头字段：同时适用请求和响应消息，但与消息主体无关的消息头


		状态码
			指HTTP请求是否成功完成
			信息响应：100-199 
				100 Continue：请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应码。允许客户端发送带请求提的请求之前，判断服务器是否愿意接收请求。如果服务器在不看请求提就拒绝请求时，客户端发送请求是不恰当或者低效的。
			成功响应：200-299
			 	200 OK：请求成功
			重定向：300-399
				302 Found：请求的资源被暂时移动到了由Location头部指定的URL上
				304 Not Modified：说明无需再次传输请求的内容，也就是说可以使用缓存的内容
			客户端错误：400-499
				400 Bad Request：由于语法无效，服务器无法理解请求
				401 Unauthorized: 由于缺乏目标资源要求的身份验证凭证
				403 Forbidden：服务器有能力处理该请求，但是拒绝授权访问
				404 Not Found：服务器无法找到所请求的资源
				405 Method Not Allowed：服务器禁止使用当前HTTP方法的请求
				406 Not Acceptable：服务器无法提供与Accept-Charset以及Accept-Language指定的值相匹配的响应
				408 Request-Timeout：服务器想要将没有在使用的连接关闭。
			服务端错误：500-599
				500 Internal Server Error：所请求的服务器遇到意外的情况并阻止其执行请求
				501 Not Implemented： 请求的方法不被服务器支持，因此无法被处理
				502 Bad Getway：作为网管或者代理角色的服务器，从上游服务器中接受到响应是无效的
				503 Service Unavailable：服务器尚未处于可以接受请求的状态（宕机或者超载）


		form提交-常用属性
			action：请求的URL
			method：请求方法（GET、POST）
			enctype：POST请求时，请求体的编码格式。application/x-www-form-urlencoded 用&分隔参数，用=分隔键和值，字符用URL编码方式进行编码
			multipart/form-data：文件上传时必须使用这种编码方式


		同源策略
			默认情况下，AJAX请求只能发送给同源的URL（同源：协议、域名、端口 ）
				Access-Control-Allow-Origin：指定哪些网站可参与ao跨来源资源共享过程中
			img、script、link、iframe、video、audio等标签不收同源策源的约束

		Cookie的作用于
			domain和path标识定义了Cookie的作用于，即Cookie应该发送给哪些URL
			domain
				标识了哪些主机可以接受Cookie
				如果不指定，默认位当前文档的主机，如果指定了domain，则一般包含子域名，如domain=520it.com，则Cookie包含bbs.520it.com
			path
				标识制订了主机下哪些路径可以接受Cookie，子路径也会被匹配
				例如path=/docs，则以下地址都会匹配：/docs  /docs/one/ /docs/one/img

		代理服务器（proxy Server）
			特点：本身不生产内容，处于中间位置转发上下游的请求和响应
				面向下游的客户端，它是服务器
				面向上游的服务器，他是客户端
			正向代理：代理的对象是服务器
				隐藏客户端身份
				绕过防火墙（突破访问限制）
				Internet访问控制
				数据过滤
			反向代理：代理的对象是客户端
				隐藏服务器身份
				安全防护
				负载均衡
			相关的头部字段：
				Via：追加经过的每一台代理服务器的主机名（或域名）
				X-forwarded-For：追加请求放的IP地址
				X-Real-IP：客户端的真实IP地址

		抓包工具的原理
			Fiddler，Charles等抓包工具的原理：在客户端启动了正向代理服务
			Wireshark的原理：通过底层驱动，拦截网卡上流过的数据

		CDN（Content Delivery Network或Content Distribution Network）内容分发网络
			利用最靠近每位用户的服务器，更快更可靠得将音乐、图片视频等资源文件传递给用户
			CDN运营商在全国各大城市都建立了机房，部署了大量拥有高存储高带宽的节点，构建了一个跨运营商、跨地狱的专用网络
			内容所有者向CDN运营商支付费用，CDN将内容交付给最终用户

		### 网络安全
		网络通信中面临的4中安全威胁
			1.截取：窃听通信内容
			2.中断：中断网络通信
			3.篡改：篡改通信内容
			4.伪造：伪造通信内容

		ARP
			ARP欺骗，又称ARP毒花、病毒、攻击，可以让攻击者获取局域网上的数据甚至可以篡改数据包，让网络上特定电脑之间无法通信，导致送至特定IP地址的流量被错误送到攻击者所取代的地方。
				C是攻击者，AB是被攻击者，C只要收到过A、B发送的ARP请求，就会拥有A、B的IP、Mac地址，就可以进行欺骗活动。
				1.C发送一个ARP响应给B，把响应包里面的源IP设为A的IP地址，源MAC地址设为C的MAC地址
				2.B收到ARP响应后，更新它的ARP表，把A的MAC地址（IP_A, MAC_A）改为（IP_A, MAC_C）
				3.当B要发送数据包给A时，它根据ARP表来封装数据包的头部，把目标MAC地址设为MAC_C，而非MAC_A 
				4.当交换机收到B发送给A的数据包时，根据此包的目标MAC地址（MAC_C）而把数据包转发给C 
				5.C收到数据包后，可以把它存起来后再发送给A，达到窃听效果。C也可以篡改数据后才发送数据包给A
			ARP防护
				1.静态ARP
				2.DHCP Snooping，网络这杯可借由DHCP保留网络上各电脑的MAC地址，在伪造的ARP数据包发送时即可侦测

		RARP
			使用与ARP相同的报头结构，作用与ARP相反，用于将MAC地址转换为IP地址，后来被BOOTP，DHCP取代

		ICMP
			（Internet Control Message Protocol）互联网控制消息协议
			通常用于返回错误先洗，比如TTL值过期，目标不可达，ICMP的错误消息总是包含元数据并返回给发送者

		Dos，DDos
			Dos攻击（Denial-of-Service attack）使目标电脑的网络或系统资源耗尽，使服务暂时中断或者停止，导致其他正常用户无法访问
			DDos工具（）Distributed Denial-of-Service attack）使用网络上两个或以上被攻陷的电脑作为僵尸向特定的目标发动Dos攻击
				带宽消耗型：
					UDP洪水攻击、
					ICMP洪水攻击
				资源消耗型：
					SYN洪水攻击：攻击者发送一系列的SYN请求到目标，然后让目标因收不到ACK而进行等待、消耗资源（跳过发送最后的ACK信息，修改源IP地址，让目标发送SYN-ACK到伪造的IP地址，因此目标永不可能收到ACK）
					LAND洪水攻击：局域网拒绝服务攻击，通过持续发送相同源地址和目标地址的欺骗数据包，使目标视图与自己建立联系，消耗资源系统直至崩溃。 
			DOS、DDos防御
				入侵检测、流量过滤、多重验证，堵塞网络贷款的流量将被过滤，而正常的流量可正常通过。
				防火墙
					防火墙可以设置规则，例如允许或者拒绝特定通讯协议，端口或者IP地址
					当攻击从少数不正常的IP地址发出时，可以简单的使用拒绝规则组织一切从攻击源IP发出的通信。
					复杂攻击难以用简单规则来阻止，例如80端口遭受攻击时不可能拒绝端口所有的通信，因为同时会阻止合法流量
					防火墙可能处于网络架构中过后的位置，路由器可能在恶意流量达到防火墙前即被攻击影响。
				交换机：大多数交换机有一定的速度限制和访问控制能力
				路由器：和交换机类似，有一定的速度显示和访问控制能力
				黑洞引导：将所有受攻击计算机的通信全部发送至一个黑洞（空接口或者不存在的计算机地址）或者足够能力处理洪流的网络设备商
				流量清晰：当流量被送到DDos防护清洗中心时，通过采用抗DDos软件处理，将正常流量和异常流量分开


		应用层-DNS劫持（域名劫持）   
			攻击或者篡改了某个域名的解析结果，使得指向该域名的IP变成了另一个IP，导致对相应网址的访问被劫持到另一个不可达的或者假冒的网站，从而实现非法窃取用户信息或者破坏正常还忘了服务器目的
			防止DNS劫持，可以考虑使用更靠谱的DNS服务器，比如：114.114.114.114
			HTTP劫持：对HTTP数据包进行连接处理，比如插入JS代码。比如访问某些网站时，多了一些弹窗广告

		HTTP协议的安全问题
			HTTP默认是采用明文传输的，因此有很大的安全隐患。常见的提高安全性的方法是：对通信内容进行加密后，再进行传输。

			常见的加密方式：
				不可逆
					单向散列函数：根据消息内容计算出散列值，散列值的长度和消息的长度五官，无论消息是1bit，10M，100G，单向散列函数都会计算出固定长度的散列值
						特点：1.根据任意长度的信息，计算出固定长度的散列值
							 2.计算速度快，能快速计算出散列值
							 3.消息不同，散列值不同
							 4.具备单向性
						MD5：（message digset）产生128bit的散列值，目前不安全
						SHA-1：产生160bit的散列值，目前不安全
						SHA-2：SHA-256、SHA-384、SHA-512，散列值长度分别是256bit、384、bit、512bit
						SHA-3：全新标准
				可逆
					对称加密：在对称加密中，加密解密使用的是同一密钥，常见的对称加密算法
						DES：（Data Encryption Standard）将64bit明文加密成64bit密文的对称加密算法，密钥长度是56位
						3DES：将DES重复3次所得到的一种密码算法，也叫做3重DES，并不是三次DES加密->DES加密->DES加密，而是DES加密->DES解密->DES加密的过程
						AES：（advance Encryption Standard）取代DES成为新标准的一种对称加密算法，又称RIjindel加密，AES密钥长度有128位，192位，256位三种，目前已经逐步取代DES，3DES成为首选的对称加密算法
						密钥配送问题：
							1.事先共享密钥
							2.密钥分配中心
							3.Diffine-Hellman密钥交换
							4.非对称加密
					非对称加密：（Asymmetric Cryptography）
						RSA:
						密钥分为加密密钥、解密密钥，并不是同一个密钥。
							加密密钥：一般是公开的，因此改密钥称为公钥
							解密密钥：由消息接受者自己保管，不能公开，因此也称为私钥

						公钥、私钥
							公钥和私钥是一一对应的，不能单独生成，一对公钥和私钥统称为密钥对。
							由公钥加密的密文，必须使用与该公钥对应的私钥才能解密。
							由私钥加密的密文，必须使用与该私钥对应的公钥才能解密。

						密钥配送
				其他
					混合密码系统
						对称加密的缺点：不能很好的解决密钥配送问题
						非对称加密的缺点：加密解密速度比较慢
						混合密码系统：是将对称加密和非对称加密的优势相结合。1.解决了非对称加密的速度慢的问题。2.非对称加密解决了对称加密的密钥配送问题。

						加密：
							会话密钥（session key），为本次通信随机生成的临时密钥，作为对称加密的密钥，用于加密消息，提高速度 
							1.消息发送者要拥有消息接受者的公钥
							2.生成会话密钥作为对称加密的密钥，加密消息
							3.用消息接受者的公钥，加密会话密钥
							4.将前两步生成的加密结果，一并发送给消息接受者
							发出去的内容：用会话密钥加密的消息（对称加密）、用公钥加密的会话密钥 （非对称加密）
						解密：
							消息接受者用自己的私钥解密出会话密钥
							在用解密出的会话密钥解密消息
					数字签名
						生成签名
							由消息的发送者完成，通过『签名密钥』生成，消息发送者的私钥进行签名
						验证签名
							有消息的接受者完整，通过『验证密钥』验证
						作用：
							确认消息的温整形
							识别消息是否被篡改
							防止消息发送人否认

					证书（Public-key Certificate PKC）
						里面有姓名、邮箱等个人信息以及此人的公钥， 由认证机构施加数字签名


		HTTPs（HyperText Transfer Protocol Secure）超文本传输安全协议
			HTTP over TSL、HTTP over SSL、HTTP Secure 
			HTTP默认端口443，HTTP默认端口80
			HTTPS是在HTTP基础上使用SSL/TSL来加密报文，对窃听和中间人攻击提供合理的防护，SSL/TSL也可以用在其他协议上，比如FTP->FTPS，SMTP->SMTPS

			TLS(Transprot Layer Security)传输层安全协议，全身是SSL（Secure Sockets Layer）安全套接层
			OpenSSL
			成本：
				证书费用
				加解密计算
				降低访问速度
			HTTPS通信过程
				1.TCP的三次握手
				2.TSL的连接
					1. Client Hello 
						TSL版本号
						支持的加密组件（Cipher Suite）列表，加密组件是指所使用的加密算法及密钥长度等
						一个随机数
					2.Server Hello
						TSL版本号
						选择的加密组件
						一个随机数
					3.Certificate
						服务器端签名证书（被CA签名过的）
					4.Server Key Exchange
						用以实现ECDHE算法的其中一个参数（Server Params），是一种密钥交换算法，为了防止伪造，Server Params经过了服务器私钥签名
					5.Server Hellow Done
						告知客户端：协商部分结束（目前为止，客户端和服务器之间通过明文共享了）
					6.Client Key Exchange
						用以实现ECDHE算法的另一个参数（Client Params）（目前为止，客户端和服务器都拥有了ECDHE算法需要的2个参数，Server Params，Client Params），客户端、服务器都可以使用ECDHE算法
						根据Server Params、Client Params 计算出一个新的随机密钥串：Pre-mater secret
						结合Client Random、Server Random、Pre-mater secret
					7.Change Cipher Spec
						告知服务器，之后的通信采用计算出来的会话密钥进行加密
					8.Finished
						包含连接至今全部报文段整体校验值（摘要），加密之后发送给服务器
					9.Change Cipher Spec
						告知客户端，之后的通信采用计算出来的会话密钥进行加密
					10.Finished
						到此为止，客户端都验证加密解密没问题，握手正式结束
				3.HTTP的请求和响应 

		HTTP/1.1的不足
			同一时间，一个连接只能对应一个请求，针对同一个域名，大多数浏览器允许同时最多6个并发连接
			只允许客户端主动发起请求，一个请求只能对应一个响应
			同一个会话的多次请求中，头信息会被重复传输，通常会给每个传输增加500-800字节的开销，如果使用Cookie，增加的开销有时会达到上千字节

		HTTP2  
			在底层传输做了很多改进和优化，但在语意上万全与HTTP/1.1兼容（所以升级不需要修改任何代码，只需要升级服务器配置和浏览器）
			HTTP/2采用二进制格式传输数据，而非HTTP/1.1的报文格式，二进制格式在协议的解析和优化扩展上带来更多的优势和可能
			数据流:已建立的连接内的双向字节流，可以承载一条或多条消息，所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向数据流。
			消息：与逻辑HTTP请求或响应对应，由一系列组成
			帧：HTTP/2通信的最小单位，每个帧都包含帧头（会标识出当前帧所属的数据流），来自不同数据量的帧可以叫做发送，然后再根据每个帧头的数据流标识符重新组装

			多路复用
				客户端和服务器可以将HTTP消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来
				并行交错的发送多个请求，请求之间互不影响
				并行交错的发送多个响应，响应之间互不干扰
				使用一个连接并行发送多个请求和响应
				不必再为绕过HTTP/1.1限制而做很多工作（image sprites、合并CSS/JS、内嵌CSS/JS/Base64图片、域名分片）
			优先级
				HTTP/2标准允许每个数据流都有一个关联的权重和依赖关系，可以向每个数据流分配一个介于1-256之间的整数，每个数据流与其他数据流之间可以存在显式依赖关系
				客户端可以构建和传递『优先级树』，表明它倾向于如何接收响应
				服务器可以使用此信息通过控制CPU，内存和其他资源的分配设定数据流处理的优先级，在资源数据可用之后，确保将高优先级响应以最优方式传输至客户端
					尽可能献给父数据流分配资源
					同级数据流（共享相同父项）应按其权重比例分配资源。  

			头部压缩
				HTTP/2使用HPACK压缩请求头和响应头，可以极大减少头部开销，进而提升性能。
				早期版本的HTTP/2和SPDY使用zlib压缩，可以将所传输头数据的大小减少85-88%，但是2012年夏天被攻击导致会话劫持，后被HPACK取代

			服务器推送
				服务器可以对一个客户端请求发送多个响应，除了最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端额外明确地请求。

			队头阻塞


		HTTP3
			QUIC（Quick UDP Internet Connections）
			TCP基于4要素（源IP、源端口、目标UP、目标端口），QUIC连接不受4要素的影响，当4要素发生变化时，连接依然维持，QUIC连接不以4要素作为标识，而是使用一组Connection ID来标识一个连接，即使IP或者端口发生改变，只要Connection ID没有变化，那么连接依然可以维持（WIFI切换到蜂窝）


		WebSocket
			HTTP请求 ，通信只能由客户端发起，所以早起很多网站为了实现推送技术，所用的技术都是轮询。
			WebSocket是基于TCP的支持全双工通信的应用层协议，跟HTTP属于平级，只是HTTP的请求-应答模式限制了TCP的能力
			与HTTP不同的是，WebSocket需要先建立连接，这就使得WebSocket成为一种有状态的协议，之后通信时可以省略部分状态信息，而HTTP请求可能需要在每个请求都额外携带状态信息。

			建立连接
				WebSokcet需要借助HTTP协议来建立连接（也叫握手），由客户端（浏览器）主动发出握手请求。
				Connection：必须设置Upgrade，表示客户端希望连接升级
				Upgrade：必须设置websocket，表示希望升级到websocket歇会
				sec-Websocket-Version：支持的websocket版本，是客户端生成的随机字符串。
					服务器接收到客户端的Sec-Websocket-Key后，会进行一下操作
					1.Sec-Websocket-key加上一个固定的GUID值
					2.将1的结果进行SHA-1摘要计算
					3.将2的结果进行base64编码
					4.将3的结果作为Sec-websocket-Accept响应头的值，返回给客户端
					这样操作，可以尽量避免普通HTTP请求被误认为WebSocket协议

		WebService
			是一种跨编程语言和跨操作系统平台的远程调用技术标准，如天气预报，手机归属查询，航班查询，物流信息查询。
			核心概念
				SOAP（simple Object Access Protocol）简单对象访问协议 = HTTP+XML，WebService使用SOAP协议来封装数据
				WSDL（Web Services Descirption Language）Web服务描述语言，一个XML文档用以描述WebService接口的细节，一般在Webservice的URL后面跟上?wsdl获取WSDL信息

		RESTFul
			REpresent State Transfer：表现层状态转义
			REST是一种互联网软件架构设计风格，定义了一组用于创建Web服务的约束，符合REST架构的Web服务，称为RESTFul Web服务
			实践建议
				URL中使用名称（建议用复数形式），不实用动词
				使用HTTP方法表达动作
				一个资源连接到其他资源，使用子资源的形式
				API版本化
				返回JSON格式
				发生错误时，不要返回200状态码

		HTTPDNS
			HTTPDNS是基于HTTP协议向DNS服务器发送域名解析请求，替代了基于DNS协议向运营商Local DNS发起解析请求的传统方法，可以避免Local DNS造成的域名劫持和跨域访问问题，常用在移动互联网中
			使用

		FTP
			File Transport Protocol：文件传输协议，基于TCP的应用层协议
			连接模式
				主动连接
					1.客户端打开一个随机的命令端口（假设位N），端口号大于1024，同时连接至服务器端命令端口21
					2.客户端开始监听N+1数据端口，同时向服务器发送一个Port命令给服务器端命令端口，此命令告诉服务器客户端正在监听的数据端口N+1，并且已经准备好从此端口接收数据。
					3.服务器打开20号数据端口，并且创建和客户端数据端口（N+1）的连接
				被动连接
					客户端通过两个随机的端口与服务器建立连接：命令端口N、数据端口N+1
					1.客户端的命令端口N用于连接服务器端命令端口21
					2 .客户端通过命令端口N发送PAV命令给服务器端命令端口21
					3.服务器打开一个随机的数据端口P，并告知客户端该端口号P
					4.客户端数据端口N+1发起与服务器数据端口P的连接
				不管是哪种模式，都需要客户端和服务器建立2个连接

		邮件相关的协议
			发邮件协议：
			SMTP（Simple Mail Transfer Protocol）:简单邮件传输协议，基于TCP，服务器端口默认25，SSL/TSL使用465端口
			收邮件协议：
			POP（Post Office Protocol）邮局协议，基于TCP，服务器默认使用端口110，SSL/TSL使用995端口
				客户端连接服务器，将会从服务器下载所有邮件（可以设置下载完成立即或者一段时间后删除服务器邮件）
				客户端的操作（删除邮件、移动到文件夹）不会跟服务器同步
				每个客户端都是独立的，都可以获得其自己的电子邮件副本
			IMAP（Internet Message Access Protocol）：英特网信息访问协议，基于TCP，服务器默认使用143端口，SSL/TSL使用993端口  
				客户端连接服务器，获取的是服务器上邮件的基本信息，并不会下载邮件（等打开邮件是，才会下载邮件）
				客户端的操作会根服务器同步（删除，移动文件）
				所有客户端使用会看到相同的邮件和相同文件夹




























