网络

网络互连模型

OSI参考模型（7层）（Open System Interconnect Reference Model）
应用层
表示层
会话层
运输层
网络层
链路层
物理层

TCP/IP协议（4层）
应用层（应用层、表示层、会话层）
运输层
网际层（网络层）
网络接口层（数据链路层、物理层）

学习研究（5层）
应用层（应用层、表示层、会话层） （报文）       HTTP-1.1-GET       				 FTP、HTTP、SMTP、DNS、DHCP  
运输层 						 （段Segments） TCP头：包含端口号、序列号				 TCP、UDP
网际层（网络层）				 （包Packets）  IP头：包含IP地址-目标IP地址-源IP地址-协议（ICMP=1、TCP=6、UDP=17） IP、ARP、ICMP
数据链路层 					 （帧frames）   以太网头：包含Mac地址-以太网相关信息              CSMA/CD、PPP
物理层  						 （比特流bits）

分层的好处：
	1.各层独立:限制了依赖关系的范围，各层之间使用标准化的接口，各层不需要知道山西盖层是如何工作的，增加或者修改一个应用层协议不会影响传输层协议。
	2.灵活性更好：比如路由器不需要应用层和传输层，分层以后路由器就可以只需加载更少的几个协议层
	3.易于测试和维护：提高了可测试性，可以独立的测试特定层，某一层有了更好的实现可以整体替换掉
	4.能促进标准化：每一层职测清楚，方便进行标准化



# 物理层：定义了接口标准、线缆标准、传输速率、传输方式等
	模拟信号：
	1.连续的信号，适合长距离传输
	2.抗干扰能力差，收到干扰时波形变形很难纠正

	数字信号：
	1.离散的信号，不适合长距离传输
	2.抗干扰能力强，收到干扰时波形失真可修复

	数据通信模型
		局域网
		PC ----数字信号（网线）---- 交换机 -----数字信号（网线）------ PC

		广域网
		PC ----数字信号（网线）---- 调制解调器 ----- 模拟信号（电话线）----- 调制解调器 ----- 数字信号（网线）------ PC

	信道（Channel）
		信息传输的通道，一条传输介质上（比如网线）可以有多条信道
		单工通信：信号只能往一个放线传输，任何时候都不能改变信号的传输反向（无线电广播）
		半双工通信：信号可以双向传输，但是必须交通通行（对讲机）
		全双工通信：信号可以同时双向传输（手机）

# 数据链路层：
	链路：从一个节点到相邻节点的一段物理线路，中间没有其他交换节点
	数据链路：在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输。不同类型的数据链路，通信协议可能不同。
		广播信道：CSMA/CD协议（不如同轴电缆，集线器等组成的网络）
		点对点信道：PPP协议（比如路由器之间的信道）
	数据链路的3个基本问题：
		1.封装成帧
			帧的数据部分：网络层传递下来的数据包（IP数据包）
			最大传输单元：每一种数据链路协议都规定了所能够传输的帧的数据长度上限，以太网的最大传输单元1500字节
		2.透明传输
			数据部分一旦出现SOH、EOT需要进行转义（用ESC填充）
		3.差错检验
			FCS：根据数据部分+首部计算得出

	CSMA/CD协议
		1.载波侦听多路访问/冲突检测
		使用率CSMA/CS的网络可以成为以太网，它传输的是以太网帧
			以太网帧的格式有：Ethernet V2标准、IEEE的802.3标准
			使用最多的是：Ethernet V2标准
		为了能够检测正在发送的真是否产生冲突，以太网的帧至少要64字节

		用交换机组件的网络，已经支持全双工通信，不需要再使用CSMA/CD，但它传输的帧依然是以太网帧，所以交换机组件网络，依然可以叫做以太网

	Ethernet V2帧 
																								IP层
						6 		 6        2        					46-1500	         	4
					目标Mac地址-源Mac地址-类型（IPV6、IPV4）--------数据（IP数据包）-------FCS 		MAC层
				8字节|						以太网Mac帧	  					|       			物理层
前同步码7 ---帧开始定界符1----												没有帧结束符

	首部：源MAC地址+目标MAC地址+网络类型
	以太网帧：首部+收据+FCS
	数据的长度至少是：64-6-6-2-4=46

	当数据部分的长度小于46字节时：1.数据链路层会在数据的后面加入一些字节填充2.接收端会将添加的字节去掉
	长度总结：以太网帧的数据长度46-1500 以太网帧的长度：64-1518（源Mac地址+目标MAC地址+网络类型+数据+FCS）

	PPP协议（Point to Point Potocol）

			| 	      首部	   		  |
			F  ---- A ---- C ---- 协议 ---- 信息部分 ---- FCS ---- F
	字节数   1       1      1       2     不 超过1500字节  2       1
 

# 网络层
	网络层数据包（IP数据包，Packet）由首部、数据2部分组成
	数据：很多时候是有传输层传递下来的数据段

			|                  32位					|
	——————	版本 --- 首部长度 --- 区分服务 ---   总长度
	首部		标识 --- 标志 --- 片偏移
	20字节	生存时间 --- 协议 --- 首部检验和
			源IP地址
	——————	目标IP地址
			可选字段（长度可变） --- 填充
			数据部分（最大1460）
			|  			总长度65535位				|

	版本：占4位 IPV6、IPV4
	首部长度：占4位，二进制乘以4才是最终长度，20最小值，60最大值
	区分服务：(QOS)占8位，可以用于提高网络质量
	总长度：占16位 首部+数据的长度之和，最大值是65535。
		由于帧的数据不能超过1500字节，所以过大的IP数据包，需要分成片传输给数据链路层
		每一篇都有自己的网络层首部
	标识：占16位，数据包的ID，当数据包过大进行分片时，同一个数据包的所有片的标识都一样，有一个计数器专门管理数据包的ID，每发出一个数据包，ID就+1
	标志：占3位，第一位：（Reserved bit）保留。第二位：（Don't Fragment）1代表不允许分片，0代表允许。第三位：（More fragments）1代表不是最右一片，0代表是最后1片。··
	片偏移：占13位，片偏移乘以8=字节偏移，每一片段长度一定是8的整数倍 
	生存时间（TTL）：占8位，每个路由器在转发之前会将TTL减1，一旦发现TTL减为0，路由器会返回错误报告。观察使用ping命令后的TTL，能够推测出对方的操作系统，中间经历了多少个路由器
		Window： 128
		Linux：64（255）
		Mac OS：60
		Mac OS X：64 


# 传输层（TCP：Transmission Control Protocol）
	传输层有两个协议：1.TCP，传输控制协议
					2.UDP（User Datagram Protocol），用户数据报协议
								 		TCP 									UDP
		连接性						面向链接									无连接
		可靠性						可靠传输，不丢包							不可靠传输，尽最大努力交付，可能丢包
		首部占用空间					大 											小
		传输速率  					慢 											快
		资源消耗						大 											小
		应用场景						浏览器、文件传输、邮件发送 						音视频通话、直播
		应用层协议					HTTP、HTTPS、FTP、SMTP、DNS					DNS


	UDP
	UDP是无连接，减少了建立和释放链接的开销
	UDP尽最大能力交付，不保证可靠交付，隐藏不需要维护一些复杂的参数，首部只有8个字节（TCP首部至少20字节）
	UDP长度：占16位，首部的长度+数据的长度
													 ————————	
				16位源端口号 				16位目标端口号  |  
				16位UDP长度				16位UDP检验和  8字节
				数据 								 ————————
	检验和：计算内容=伪首部+首部+数据
			伪首部：源IP地址、目标IP地址、0（保留）、17（协议）、UDP长度 
			首部：源端口、目标端口、长度、检验和
	端口：占16位，可以推测出端口号的取值范围是0-65535，客户端的端口是临时开启的随机端口，防火墙可以设置开启、关闭某些端口提高安全性
		netstat -an:查看被占用的端口
		netstat -anb：查看被占用的端口、占用端口的应用程序
		telnet 主机 端口：查看市口可以访问主机的 某个端口


	TCP
	| 								16字节								|			16字节					|	
	----	源端口  																目标端口
			序列号
	20字节	确认号
			数据偏移	 	保留（flags） URG  ACK   PSH   RST   SYN   FIN   		窗口大小
	----	检验和    															紧急指针
			选项（长度可变） 														填充
 
 	序列号：占4字节。传输过程的每一个字节都会有一个编号，在建立连接后，序号代表：这一次传给对方的TCP数据部分的第一个字节的编码
 	确认号：占4字节。在建立连接后，确认号代表：期望对方下一次传过来的TCP数据部分的第一个字节的编号 
 	窗口：占2字节，这个字段有流量控制功能，能以告知对方下一次允许发送的数据大小（字节为单位）
	数据偏移：占4位，取值范围0x0101-0x1111，数据便宜乘以4=首部长度

			 UDP首部中占16位的长度字段是冗余的，纯粹是为了保证首部是32bit对齐
			 TCP/IP的数据长度，完全可以由IP数据包的首部推测出来
			 传输层的数据长度=网络层的总长度-网络层首部的长度-传输层首部的长度
	检验和： 伪首部+首部+数据
			伪首部：占用12字节，仅在计算检验和时起作用，并不会传递给网络层
	URG：（Urgent） 当URG = 1时，紧急指针字段才有效。表明当前报文段中有紧急数据，应优先尽快传递
	ACK：（Acknowledge） 当ACK = 1时，确认号字段才有效
	PSH：（Push）
	RST：（Reset） 当RST = 1时，表明连接中出现严重差错，必须释放连接，然后重新建立链接。
	SYN：（Synchroinzation） 当SYN = 1，ACK = 0时，表示这是一个建立链接的请求，若对方同意建立链接，则恢复SNY = 1，ACK = 1
	Fin：（Finish） 当Finsh = 1时，表明数据已经发送完毕，要求释放连接

	可靠传输：
		ARQ：Automatic Repeat-request，自动重传请求
		停止等待ARQ协议：等收到确认消息后再发送新的数据
		连续ARQ协议+滑动窗口协议： 如果接收窗口最多能接收4个包，但发送发只发了2个包，接受方等到一定时间后没收到第3个包，就回返回确认收到第2个包
		SACK（选择性确认）：
			1.在TCP通信过程中，如果发送序列中间某个数据包丢失（1、2、3、4、5丢了3），TCP会通过重传最后确认的分组后续的分组（最后确认2，所以重传3、4、5），这样原先已经正确传输的分组也可能重复发送，降低了TCP性能。为了改善上述情况，发展除了SACK（Selective Acknowledgment），告诉发送方哪些数据丢失，哪些数据已经收到。使用TCP只重新发送（3），不用发送的后续分组（4、5）。
			2.SACK信息会放在TCP首部的可选部分。Kind占一个字节 = 5，Length占一个字节，表明SACK一共占用多少字节。Left Edge：占4字节，左边界。Right Edge：占4字节，右边界。一堆边界信息需要占用8字节，由于TCP首部的选项部分最多40字节，所以SACK选项最多携带4组边界信息，SACK选项的最大占用字节数 = 4 * 8+2 = 34
		

	流量控制：
		如果接收方的缓存区满了，发送方还在发送数据，接收方只能把收到的数据包丢掉，大量的丢包会浪费网络资源，所以需要进行流量控制。
		什么是流量控制？让发送方的发送速率不要太快，让接收方来得及接收处理。
		原理：通过确认报文中窗口字段来控制发送方的发送速率，发送方的窗口大小不能超过接收方给出的窗口大小，当发送方收到的接收窗口大小为0时，发送方就回停止发送数据。

		特殊情况：开始接收方给发送方发送了0窗口的报文段，后面接收方有一些接收空间了，给发送方发送的非0窗口报文段丢失，发送方的发送窗口一直为0，双方陷入僵局
		解决方案：当发送方收到0窗口通知时，发送方停止发送报文，并且通知开启一个定时器，隔一段时间就发个测试报文去询问接收方最新的窗口大小，如果接收到窗口大小还是0，则发送方再次刷新启动定时器。


	拥塞控制：
		防止过多的数据注入到网络中，避免网络中的路由器或者链路过载。
		拥塞控制是一个全局性的过程，涉及到所有的主机、路由器以及与降低网络传输性能有关的所有因素，相比而已流量控制是点对点通信的控制。

		慢开始（slow start）：cwnd的初始值比较小，然后随着数据包被接收方确认，cwnd就成倍增长
		拥塞避免（congestion avoidance）：拥塞窗口缓慢增大，以防止网络过早出现拥塞，只要网络出现拥塞，把ssthresh减半，同时执行慢开始算法
		快速重传（fast retransmit）：接收方每收到一个失序的分组后就立即发出重复确认，使发送方及时知道有分组没有达到，而不要等待自己发送数据时才确认。发送方只要连续收到3个重复确认（总共4个相同的确认），就应该立即重传对方尚未收到的报文段，而不必继续等待重传计时器到后期再重传。
		快速恢复（fast recovery）：当发送方连续收到3个重复确认，就执行乘法减小算法，把ssthresh减半，与慢开始不同之处是现在不执行慢开始算法，即swnd现在不恢复到初始值二十吧cwnd设置为sshthresh减半后的值，然后开始执行拥塞避免算法，使拥塞窗口缓慢线性增大。
			MSS（Max Segment Size）：每个段最大的数据部分大小
			cwnd（congestion window）：拥塞窗口
			rwnd（receive window）：接收窗口
			swnd（send window）：发送窗口
			ssthresh（slow start threshold）：慢开始阈值，cwnd达到阈值后，以线性方式增加。





	连接管理： 
		确认号、序号
	 		---- SYN = 1 ACK = 0 seq = s1     ack = 0      --->
	 client	<--- SYN = 1 ACK = 1 seq = s2     ack = s1 + 1 ----	server
	 		---- SYN = 0 ACK = 0 seq = s1 + 1 ack = s2 +1  --->

	 	建立连接-3次握手
	 			客户端 																		服务端
	 			closed（关闭）  			> SYN = 1 ACK = 0 seq = s1     ack = 0 1 > 			listen(监听)
	 			syn-send（同步已发送）    < SYN = 1 ACK = 1 seq = s2     ack = s1 + 1 <		syn-rcvd（同步已接收）
				established（连接已经建立）> SYN = 0 ACK = 0 seq = s1 + 1 ack = s2 +1 > 		established（连接已经建立）

		双方会交换确认一些信息：MSS、是否支持SACK、Window scale（窗口缩放系数）（放在首部可选项部分中）

		为什么建立连接的时候需要3次握手，2次不行？
		1.主要目的是防止server一直等待，浪费资源
		2.如果建立连接的时候只需要2次握手，可能会出现
			client发出第一个连接请求报文段，因为网络延迟，在连接释放后才达到server，server会向client发出确认报文，同意建立连接。如果不采用3次握手，server只要发出确认，新的连接就会建立。由于现在client并没有真正想连接服务器的意愿，因此不会理睬server的确认，也不会向server发送数据。

		第3次握手失败了，会怎么处理？
		1.此时server的状态为syn-rcvd，若等不到client的ACK，server会重新发送SYN+ACK包
		2.如果server多次重发SYN+ACK都等不到client的ACK，就回发送RST包，强制关闭连接。


		释放链接-4次挥手
				客户端 																			服务端
				established（连接已经建立）	>FIN = 1,ACK = 1,seq = u,ack = v>连接释放			established（连接已经建立）
				fin-wait-1（终止等待1）		<FIN = 0,ACK = 1,seq = v,ack = u+1<确认		    	close-wait（关闭等待）
				fin-wait-2（终止等待2）		<FIN = 1,ACK = 1,seq = w,ack = u+1<连接释放			last-ack（最后确认）
				time-wait（时间等待）			>FIN = 0,ACK = 1,seq = u+1,ack = w+1>确认
				close（关闭） 																		close（关闭）

			为什么释放连接需要4次挥手？
			1.TCP是全双工模式，第1次挥手：当主机1发出FIN报文段时，表示主机1告诉主机2，主机1已经没有数据要发送了，但是主机1还是可以接受来自主机2的数据
							 第2次挥手：当主机2返回ACK报文时，表明主机2已经知道主机1没有数据发送了，但是主机2还是可以发送数据给主机1的
							 第3次挥手：当主机2也发送了FIN报文段时，表示主机2告诉主机1，主机1没有数据要发送
							 第4次挥手：当主机1返回ACK报文时，表示主机1已经知道主机2没有数据发送，随后正式断开TCP连接。

			TCP/IP协议栈在设计上，允许任何一方先发起断开请求。
			Client发送ACK后，需要有个TIME-Wait阶段，等待一段时间后，再真正关闭连接。一般是等待2倍的MSL（Maximun Segment Lifetime，最大分段生存期，大概2分钟）。
			如果Client发送ACK后马上释放了，然后又因为网络原因，server没有收到client的ACK，server就回重发FIN，可能Client没有任何响应，服务器干等，甚至多次重发Fin，浪费资源
	













