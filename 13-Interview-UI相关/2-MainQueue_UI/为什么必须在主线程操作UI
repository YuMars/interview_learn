为什么必须在主线程操作UI

我们常用的UIKit.framework并不是线程安全的，UI操作涉及到渲染或者访问各种view对象的属性，如果异步操作下会存在读写问题，而且其加锁会消耗大量资源并拖慢运行速度。另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递，所以view只能在主线程上才能对事件进行响应。在渲染方面由于图像的渲染需要60帧的刷新率在屏幕上同时更新，在非主线程异步的情况下无法确定这个处理过程能够实现同步更新。

# UIKit线程不安全
在UIKit中，很多类中大部分的属性欧度被修饰为nonatomic，这意味着他们不能在多线程的环境下工作，而对于UIKit库，要将其所有属性都设计为线程安全是不现实的，期中涉及很多方面：
1.假设能够异步设置view的属性，是设置的属性同时生效还是按照各自的runloop改变生效
2.UITableView在某个线程删除一个cell，在另外一个线程对这个cell进行操作
3.在后台线程移除一个view，这个时候runloop周期还没结束，在主线程点击这个将要消失的view，要不要响应对应的点击事件。
.....

# Runloop与绘图
UIApplication在主线程所初始化的Runloop我们称之为Main Runloop，它负责处理app存活期间的大部分事件，如用户交互等，它一直处于不断处理事件和休眠的循环之中，以确保能尽快的将用户事件传递给GPU进行渲染，使用户行为能够得到响应，画面之所以能够不断刷新也是因为Main Runloop一直在刷新。
每个view的属性修改，变化并不是立刻改变的，而是在当前Runloop结束的时候统一绘制，这样设计的目的是为了能够在Runloop里面处理好需要变化的view，包块size，hide，position等，让所有的改变都在同一时刻生效，这个机制成为绘图循环（View Drawing Cycle)。
## 渲染系统框架
	UIKit: 包含各种控件，负责对用户操作事件的响应，本身并不提供渲染的能力
	Core Animation: 负责所有视图的绘制、显示与动画效果
	OpenGL ES: 提供2D与3D渲染服务
	Core Graphics: 提供2D渲染服务
	Graphics Hardware: 指GPU
在iOS中，所有视图的实现与动画本质上是Core Animation负责，而不是UIKit.

[图]

Core Animation的绘制是通过Core Animation Pipeline实现，它以流水线的形式进行渲染，具体分为四个步骤
1.Commit Transaction：
	Layout:构件视图布局如addSubview
	Display:重载drawRect:进行视图绘制，该步骤使用CPU与内存
	Prepare:主要处理图像的解码与格式转换等操作
	commit:将Layer递归打包并发送到Render Server

2.Render Server：负责渲染工作，会解析上一步Commit Transaction中提交的信息并反序列化成渲染树（render tree，随后根据layer的各种属性生成绘制指令，并在下一次VSync信号到来时调用OpenGL进行渲染。

3.GPU：GPU会等待显示器的VSync信号发出后才进行OpenGL渲染管线，将3D几何数据转化成2D的像素图像和光栅处理，随后进行新的一帧的渲染，并将其输出到缓冲区。

4.Dispaly：从缓冲区中取出画面，并输出到屏幕上。

	·VSync:VSync（vertical sync）是指垂直同步，在玩游戏的时候在设置的时候应该会看见过这个选项，这个机制能够让显卡和显示器保持在一个相同的刷新率从而避免画面撕裂。在iOS中，屏幕具有60Hz的刷新率，这意味着它每秒需要显示60张不同的图片（帧），但GPU并没有一个确定的刷新率，在某些时候GPU可能被要求更强力的数据输出来确保渲染能力，这时候他们可能比屏幕刷新率（60Hz）更快，就会导致屏幕不能完整的渲染所有GPU给他的数据，因为它不够快，屏幕的上一帧还没渲染完，下一帧就已经到来了，这就导致画面的撕裂。这个时候我们就要引入VSync了，简单来说它就是让显卡保持他的输出速率不高于屏幕的刷新率，启用了VSync后，GPU不再会给你可怜的60Hz屏幕每秒发送100帧了，它会增加每一帧的发送间隔，确保显示器能够有充足的时间去处理每一帧。
	·双缓冲机制：双缓冲机制是用于避免或减少画面闪烁的问题，在单缓冲的情况下，GPU输出了一帧画面，缓冲区就需要马上获取这个画面，并交给显示屏去显示，而这段时间GPU输出的画面就全都丢失了，因为没有缓冲区去承载这些画面，就会造成画面的闪烁。而在双缓冲机制下有一个Back Frame Buffer和一个Front Frame Buffer，在GPU绘制完成后，它会将图像先保存到Back Frame Buffer中，操作完毕后，会调用一个交换函数，让绘制完成的Back Frame Buffer上的图像交换到Front Frame Buffer上。由于双缓冲利用了更多显存与CPU消耗时间，从而避免了画面的闪烁。

	Core Animation Pipeline是以流水线的形式工作的，在理想的状况下我们希望它能够在1/60s内完成图层树的准备工作并提交给渲染进程，而渲染进程在下一次VSync信号到来的时候提交给GPU进行渲染，并在1/60s内完成渲染，这样就不会产生任何的卡顿。

Core Animation Pipeline是以流水线的形式工作的，在理想的状况下我们希望它能够在1/60s内完成图层树的准备工作并提交给渲染进程，而渲染进程在下一次VSync信号到来的时候提交给GPU进行渲染，并在1/60s内完成渲染，这样就不会产生任何的卡顿。

[ios图形渲染原理](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)
