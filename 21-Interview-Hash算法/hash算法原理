hash算法原理

散列的概念
	散列方法的主要思想是根据结点的关键字值来确定其存储地址：
		存储：
			以关键字值K为自变量，通过一定的函数关系hash(K)---(散列函数)，计算出对应的函数值，把这个值解释为结点的存储地址，将结点存入到此存储单元中。
		检索：
			用上述同样的方法计算地址，然后找到响应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。
	散列（hash）是一种重要的存储方式，也是一种常见的检索方式。也可以用作加密明文，因为有这良好的不可逆性，在密码学中有这十分充分的应用。

	按散列存储方式构造的存储结构称为散列表（hash table）。散列表中的一个位置称为槽（slot），散列技术的核心是散列函数（hash function）。对任意给定的动态查找表，如果选定某个理想的散列函数及对应的散列表（hash table），则对应动态查找表的每个数据元素X。函数值h（X.key）就是X在散列表HT中的存储位置。插入（或建表）时数据元素X将被安置在该位置上，并且检索X时也到该位置上去查找。由散列函数决定的存储位置称为散列地址。因此，散列的核心就是：由散列函数决定关键字值X.key与散列地址hash(X.key)之间的对应关系，通过这个关系来实现存储与检索。

	一般情况下散列表的存储空间是一个一维数组HashTable[M]，散列地址的数组的下表。设计散列方法的目标就是设计某个散列函数hashFunction， 0<=hashFuction(X.key)<M;对关键字值X，得到HashTable[i] = X。一般散列表的空间必须必结点的集合大，因此虽然浪费一些空间，但是换区的是检索效率。
		M：散列表的空间大小
		N：填入表中的结点数（散列表的负载引子load factor）
	建立散列表时，若关键码与散列表是一对一对关系，则在检索时只需要根据散列函数对给定值进行运算，即可得到待查结点的存储位置。但是，散列函数可能对于不相等的关键字值计算出相同的散列地址，这种现象称为hash冲突，发生冲突的两个关键码称为该散列函数的同义词。在实际应用中，很少存在不产生冲突的散列函数，所以必须要考虑冲突发生时的处理办法。

	散列函数的特点：
		1、正向快速：给定关键字和散列函数，有限时间和资源内能计算出散列（hash）值
		2、逆向困难：只给定hash值，你很难逆向算出关键字。
		3、输入敏感：原始输入信息修改一点点，产生的hash值也能有较大的不同。
		4、冲突避免：你很难找到两个不同的关键字算出的散列值是相同的（发生冲突）。

散列函数
	以处理整型的关键字值为例，HashTable为M个元素。散列函数的选取原则是：运算尽可能简单；函数的值域必须在散列表的范围内；尽可能使得结点均匀分布，也就是尽量让不同的关键码具有不同的散列函数值。需要考虑各种因素：关键码长度、散列表大小、关键码分布情况、记录的检索频率等等。

	除余法
		用关键字值X除以M，并取余数作为散列地址。(整数相除比较简单，但是运行速度慢)
		散列函数为： h(x) ＝ x % M。

	乘余取整法
		用关键字值X.key乘上一个常数A（0 < A < 1），比如黄金比例0.618，提取乘积的小数部分。然后，再用整数n乘以这个值，对结果向下取整，把它作为散列的地址。
		散列函数为：hash(X.key) = _LOW( n × ( A × key % 1 ) )。其中，“A × key % 1”表示取 A × key 小数部分，即： A × key % 1 = A × key - _LOW(A × key), 而_LOW(X)是表示对X取下整
	平方取中法
		用关键字值X.key的平方值，扩大相近数的差别，然后根据表长度取中间的几位数作为散列函数值。因为一个乘积的中间几位数与乘数的每一位都相关，所以由此产生的散列地址比较均匀。
		关键字	关键字的平方	哈希函数值
		1234	1522756			227
		2143	4592449			924
		4132	17073424		734
		3214	10329796		297

	数字分析法
		假设关键字值集合中的每个关键字都是s位数字组成（u1,u2,u3,u4,un）分析关键字集合中的全体，并从中提取分布均匀的若干位或它们的组合作为地址。数字分析法是取数据元素关键字值中某些取值分散较均匀的数字位作为哈希地址的方法。即当关键字值的位数很多时，可以通过对关键字的各位进行分享，丢掉分布不均匀的位作为hash值。它只适用于所有关键字值已知的情况，通过分析分布情况把关键字取值区间转化为一个娇小的关键字取值区间。

		关键字值：K1=61317602 K2=61326875 K3=62739628 K4=61343634 K5=62706815 K6=62774638 K7=61381262 K8=61394220
		分析上述8个关键字可知，关键字从左到右的第1、2、3、6位取值比较集中，不宜作为哈希地址，剩余的第4、5、7、8位取值较均匀，可选取其中的两位作为哈希地址。设选取最后两位作为哈希地址，则这8个关键字的哈希地址分别为：2，75，28，34，15，38，62，20。

	基数转换法
		将关键字值看成另外一种进制的数再转换成原来进制的数值，然后选其中几位作为散列地址。
		例Hash(80127429)=(80127429) 13=8*13^7+0*13^6+1*13^5+2*13^4+7*13^3+4*132+2*13^1+9 = (502432641)10 
		如果取中间三位作为哈希值，得Hash（80127429）=432
		为了获得良好的哈希函数，可以将几种方法联合起来使用，比如先变基，再折叠或平方取中等等，只要散列均匀，就可以随意拼凑。

	折叠法
		如果关键字值所含的位数很多，采用平方取中法计算太复杂，可以将关键字值分隔成相同的几部分，然后取这几部分的叠加和作为新的关键字值进行散列函数。
		位叠加法：将分割后的几部分低位对齐叠加
		边界叠加法：从一端研分割界来回折叠，然后对齐相加。

冲突解决
	尽管散列函数的目标是使冲突最少，但实际上冲突无法避免。解决冲突的技术可以分为两类
		开散列方法（拉链法）：open hashing 
			把发生冲突的关键字值存储在散列表主表之外

			分离链表发
				1.拉链法
				开散列方法的一种简单形式是把散列表中的每个槽定义为一个链表的表头，散列表的一个特定槽的所有记录都放到这个槽的链表中。[图1]说明了一个开散列的列表，这个表中每一个槽存储一个记录和一个指向链表其余部分的指针。这这7个数存储在有11个槽的散列表中，使用的散列函数是hashFunction(K) = K % 11。数的插入顺序是77、7、110、95、14、75和62。有2个值散列到第0个槽，1个值散列到第3个槽，3个值散列到第7个槽，1个值散列到第9个槽。

				[图1]

		闭散列方法（开地址法）：close hashing
			把发生冲突的关键字值存储在表中另外一个槽slot内

			闭散列表方法把所有记录直接存储在散列表中。每个记录关键字值X.key有一个由散列表函数计算出来的基位置，如果要插入一个关键字，而另一个记录已经占据了此位置（发生碰撞），那么就把后插入的关键字存储在其他地址内，由解决冲突策略确定是哪个地址。

			闭散列表解决冲突的基本思路是：当冲突发生时，使用某种方法位关键字值生成一个散列地址序列，d0,d1,d2,d3,d4.....其中d0=hashFunction(X.key)称为X的基地址位置，所有di（0>i<M）是后续散列地址。当插入X.key时，若地址上的结点已被别的数据元素占用，则按上述地址序列依次探查，将找到的第一个开放的空闲位置di作为X的存储位置。若所有后续散列地址都不空闲，说明该闭散列表已满，报告溢出。相应的，检索X时，将按同值的后续地址序列依次查找，检索成功时返回该位置di。如果沿着检索序列检索时，遇到开放的空闲空间，则说明表中没有待查的关键字值。删除X时，也按同值的后续地址序列依次查找，查找到某个位置di具有该X值，则删除该位置di上的数据元素。如果遇到开放的空闲地址，说明表中没有待删除的关键字值。因此对于闭散列表，构造后继散列地址序列的方法，也就是处理冲突的方法。
				线性探测法
					将散列表看成是一个环形表，若在基地址d（即hashFunction（X.ke) = d）发生冲突，则一次探查下述地址单元：d+1,d+2,d+3.....M-1，0,1,...d-1直到找到一个空闲地址或查找到关键字值为X.key的结点为止。若沿着该探查序列检索一遍后，又回到了地址d，则无论是插入操作还是检索操作，都意味着失败。用于简单线性探查的函数是p(X,i)

					已知一组关键码为（26，36，41，38，44，15，68，12，06，51，25），散列表长度M= 15，用线性探查法解决冲突构造这组关键码的散列表。 因为n=11，利用除余法构造散列函数，选取小于Ｍ的最大质数P=13，则散列函数为：h(key) = key%13。按顺序插入各个结点： 26: h(26) = 0，36: h(36) = 10， 41: h(41) = 2，38: h(38) = 12， 44: h(44) = 5。 插入15时，其散列地址为2，由于2已被关键码为41的元素占用，故需进行探查。按顺序探查法，显然3为开放的空闲地址，故可将其放在3单元。类似地，68和12可分别放在4和13单元中.

				二次探查法
					生成的后续散列地址不是连续的，而是跳跃式的，以便为后续数据元素留下空间从而减少聚集。二次探查法的探查序列依次位：1^2,-1^2,2^2,-2^3,.....
					 di = 1^2 , -1^2 , 2^2 , -2^2 , …, p( K，2 i-1) = i*i p( K，2 i) = - i*i

				随机探查法
					在探查序列中从未访问过的槽中选择下一个位置，即探查序列应当是散列表位置的一个随机排列。实际上不能随机的探查序列中选择一个位置，因为在检索关键字值的时候不能建立同样的探查序列。然而，我们可以做一些类似于伪随机探查的事情。在伪随机探查中，探查序列的第i个槽是(h(X.key) + ri) % M，其中ri是1到M-1之间数的随机数序列。所有插入和检索都是同相同的随机数。探查函数 p(K，i) = perm[i - 1]，这里perm是一个长度为M - 1的数组，它包含值从1到M – 1的随机序列。

					例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元，参图8.26 (a)。如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元，参图8.26 (b)。如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元

				双散列探查法
					伪随机探查和二次探查都能消除基本聚集——即基地址不同的关键码，其探查序列的某些段重叠在一起——的问题。然而，如果两个关键码散列到同一个基地址，那么采用这两种方法还是得到同样的探查序列，仍然会产生聚集。这是因为伪随机探查和二次探查产生的探查序列只是基地址的函数，而不是原来关键码值的函数。这个问题称为二级聚集( secondary clustering )。

				为了避免二级聚集，我们需要使得探查序列是原来关键码值的函数，而不是基位置的函数。双散列探查法利用第二个散列函数作为常数，每次跳过常数项，做线性探查





















	https://www.jianshu.com/p/f9239c9377c5
	https://www.cnblogs.com/tanyui/p/14191064.html=i