卡顿优化

#卡顿检测：
	简单来说，主线程需要达到60fps的绘制效率，不能在主线程有单个耗时超过1/60≈16ms的计算任务。通过设置Instrument16ms的采样频率可以检测出

## 基于Runloop：
	主线程绝大部分计算或者绘制任务都是以Runloop为单位发生。单次Runloop如果时长超过16ms(1/60s),就会导致UI体验的卡顿。可以通过Runloop的生命周期来表示卡顿。Runloop每次进入事件开始和结束，来分析卡顿
```
- (void)setupRunloopObserver{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        CFRunLoopRef runloop = CFRunLoopGetCurrent(); 
        CFRunLoopObserverRef enterObserver;
        enterObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(),
                                               kCFRunLoopEntry | kCFRunLoopExit,
                                               true,
                                               -0x7FFFFFFF,
                                               BBRunloopObserverCallBack, NULL);
        CFRunLoopAddObserver(runloop, enterObserver, kCFRunLoopCommonModes);
        CFRelease(enterObserver);
    });
}
static void BBRunloopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {
    switch (activity) {
        case kCFRunLoopEntry: {
            NSLog(@"enter runloop...");
        }
            break;
        case kCFRunLoopExit: {
            NSLog(@"leave runloop...");
        }
            break;
        default: break;
    }
}
```
kCFRunLoopExit的时间，减去kCFRunLoopEntry的时间，即为一次Runloop所耗费的时间，这样能找出大于16ms的Runloop。

## 基于线程
最理想的方案是让UI线程主动汇报当前耗时任务，每隔16ms让UI线程报到一次，如果16ms之后UI线程没有报到，那么一定在执行一个耗时任务（这里感觉如果说是前15ms都没做事，最后要报到的那1ms开始执行繁重任务，也会做到无法报到。所以这个方案这里可以优化）。
	1.启动一个worker线程，每隔一段时间ping一下主线程（发送通知）
	2.主线程如果有空，会接收到通知，并pong（发送另外一个通知）worker线程
	3.如果worker线程没收到时间间隔内的pong回复，则主线程在执行其他任务，反之则主线程空闲
	4.主线程繁忙的时候，暂停线程，打印主线程当前的函数调用栈。
iOS的多线程一般使用NSOperation或者GCD，这两者都无法暂停每个正在执行的线程。如果从woker线程发送signal，UI线程会被立即停止，并进入singal的回调，再讲callstack打印，这样就可以定位卡顿的时候函数调用
```
signal(CALLSTACK_SIG, thread_singal_handler);
```

```
//在主线程注册signal handler
signal(CALLSTACK_SIG, thread_singal_handler);

//通过NSNotification完成ping pong流程
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(detectPingFromWorkerThread) name:Notification_PMainThreadWatcher_Worker_Ping object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(detectPongFromMainThread) name:Notification_PMainThreadWatcher_Main_Pong object:nil];

//如果ping超时，pthread_kill主线程。
pthread_kill(mainThreadID, CALLSTACK_SIG);

//主线程被暂停，进入signal回调，通过[NSThread callStackSymbols]获取主线程当前callstack。
static void thread_singal_handler(int sig) {
    NSLog(@"main thread catch signal: %d", sig);
    if (sig != CALLSTACK_SIG) {
        return;
    }
    NSArray* callStack = [NSThread callStackSymbols];
    
    NSLog(@"detect slow call stack on main thread! \n");
    for (NSString* call in callStack) {
        NSLog(@"%@\n", call);
    }
    return;
}
```
上述方法不能调试，调试时gdb会干扰singal的处理，导致singal handler无法进，在UI线程遇到卡顿是能正常回调。

## CADisplayLink监控（监控FPS）
CADisplayLink监控的思路是每个屏幕刷新周期，派发标记位设置任务到主线程中，如果多次超出16.7ms的刷新阙值，即可看作是发生了卡顿。

>什么是CADisplayLink？
CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。
我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和selector 在屏幕刷新的时候调用。
一旦 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。
例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。
在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。
duration属性提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是 duration只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。
frameInterval属性是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval 设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。
我们通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate
从runloop中删除并删除之前绑定的 target跟selector
>另外CADisplayLink 不能被继承。

```
#define LXD_RESPONSE_THRESHOLD 10
dispatch_async(lxd_fluecy_monitor_queue(), ^{
    CADisplayLink * displayLink = [CADisplayLink displayLinkWithTarget: self selector: @selector(screenRenderCall)];
    [self.displayLink invalidate];
    self.displayLink = displayLink;

    [self.displayLink addToRunLoop: [NSRunLoop currentRunLoop] forMode: NSDefaultRunLoopMode];
    CFRunLoopRunInMode(kCFRunLoopDefaultMode, CGFLOAT_MAX, NO);
});

- (void)screenRenderCall {
    __block BOOL flag = YES;
    dispatch_async(dispatch_get_main_queue(), ^{
        flag = NO;
        dispatch_semaphore_signal(self.semphore);
    });
    dispatch_wait(self.semphore, 16.7 * NSEC_PER_MSEC);
    if (flag) {
        if (++self.timeOut < 1) { return; }
        // TODO:FPS丢失
    }
    self.timeOut = 0;
}
```

方案		优点					缺点								实现复杂性
FPS		直观				无法准确定位卡顿堆栈						简单
RunLoop Observer		能定位卡顿堆栈					不能记录卡顿时间，定义卡顿的阈值不好控制	复杂
Ping Main Thread		能定位卡顿堆栈，能记录卡顿时间		一直ping主线程，费电	中等